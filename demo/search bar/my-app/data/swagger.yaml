swagger: '2.0'

info:
  version: 'v1'
  title: ONTAP REST API
  contact:
    name: NetApp Support
    url: https://mysupport.netapp.com
  description: |
    ONTAP adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br>

    ## Using the ONTAP REST API online documentation
    Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method.

    ## Features for all ONTAP APIs
    <details id="Getting_started_with_the_ONTAP_REST_API">
      <summary>Getting started with the ONTAP REST API</summary>

      ### Overview
      Let's review some key things about RESTful APIs and how they're implemented in ONTAP:
      * REST API URLs identify the resources that you'll be working with, including clusters, SVMs, and storage.
      * REST APIs use HTTP methods GET, POST, PATCH, DELETE, and OPTIONS to indicate their actions.
      * REST APIs return common HTTP status codes to indicate the results of each call. Additional error details can be included in the results body.
      * REST APIs request and response bodies are encoded using JSON.
      * REST APIs support hyperlinking among resources using the Content-Type "application/hal+json".
      * GET calls on collections usually return only name and UUID by default. If you want to retrieve additional properties, you need to specify them using the “fields” query parameter.
      * ONTAP supports query-based DELETE or PATCH for all collection endpoints.

      If you're already familiar with the ONTAPI API (also known as ZAPI), there are some similarities between ONTAP REST APIs and ONTAPI. For example:
      * Both support the same transport and security mechanisms.
      * Both paginate results based on either number of seconds or number of records.
      * Both support filtering the returned records based on property values.
      * Both support limiting the returned properties.
      * Both support concurrent requests. If ONTAP temporarily can't handle additional calls, it will respond with an HTTP error status code of 503.

      However, there are important differences between REST APIs and the ONTAP CLI and ONTAPI that you should understand as well:
      * In many cases, ONTAP REST APIs use different names for fields and features.
      * REST APIs do not expose infrequently used CLI parameters.
      * REST APIs do not treat the cluster or nodes as an SVM (aka Vserver).
      * REST GET APIs support specifying a maximum time before paginating results. However, the default time is 15 seconds for REST (instead of 90 seconds for ONTAPI).
      * REST APIs are generally ordered by UUID or ID, so a rename operation using the PATCH method doesn't change the path keys.
      * REST APIs use one or more of the following properties to identify a resource: "name", "uuid", "id".
      * REST APIs often execute the equivalent of multiple CLI commands in a single request.
      * REST API properties use underscores instead of hyphens between words.
      * REST API dates are always in ISO-8601 format.
      * REST API comparisons between enum values (for <, >, ranges, and `order_by`) are done alphabetically. (In CLI and ONTAPI, enum comparisions are done based on an internal value for the enum.)
      * REST API field '<' queries exclude records where the specified field is not set. You can add "|null" (eg: limit=<10|null) to also return records where the specified field is not set.

    </details>

    <details id="HAL_linking">
      <summary>HAL linking</summary>

      ### Hypertext Application Language (HAL)
      ONTAP REST APIs use HAL as the mechanism to support Hypermedia as the Engine of Application State (HATEOAS). When an object or attribute is returned that identifies a specific resource, a HAL-encoded link is also returned so that you can easily discover resources and be able to obtain more details about the resource.

      #### Example
      ```
      "aggregate": {
          "uuid": "19425837-f2fa-4a9f-8f01-712f626c983c",
          "name": "aggr0",
          "_links": {
              "self": {
                  "href": "/api/storage/aggregates/19425837-f2fa-4a9f-8f01-712f626c983c"
              }
          }
      }
      ```

    </details>

    <details id="Query_parameters">
      <summary>Query parameters</summary>

      ### Overview
      The following is a list of all the globally supported query parameters. This list is intended as a quick reference for syntax purposes. The query parameters are described in more detail in other sections of this documentation. Note that multiple queries can be combined using an "&".
      <br/>
      ```
      # Request specific fields
      fields=<field>[,...]

      # Query fields by value. If the value contains query characters (*|,!<>..), it must be quoted to avoid their special query meaning
      <field>=<query value>

      # Return the records array
      return_records=<true|false>

      # Timeout and return after the specified number of seconds
      return_timeout=<0..120 seconds>

      # The number of records to collect (or act on for query-based PATCH/DELETE) before returning
      max_records=<number of records>

      # Request a customized sort ordering
      order_by=<field [asc|desc]>[,...]
      $orderBy=<field [asc|desc]>[,...]

      # Pretty print JSON response bodies
      pretty=<true|false>

      # Continue after encountering a failure. Only applicable to query-based PATCH and DELETE.
      continue_on_failure=<true|false>

      # Begin returning records starting at an offset from the first record
      offset=<offset from first record>
      ```

    </details>

    <details id="Query_based_PATCH_and_DELETE">
      <summary>Query-based PATCH and DELETE</summary>

      ### Overview
      Although they are not documented as individual methods in the list of REST APIs, every API supporting PATCH or DELETE on a resource instance also supports PATCH or DELETE on the collection as long as at least one field is specified in the query portion of the URL. A PATCH or DELETE method issued on a collection is equivalent to internally doing a query-based GET, followed by a serial PATCH or DELETE operation on each matching record. However, it only does the operation for `return_timeout` seconds, which is 15 seconds by default. If a query-based operation is not completed before `return_timeout` seconds, the API returns a next link. The client must use the next link with the same HTTP method to continue the operation. Query-based operations will not continue to the next record until the operation on the prior record is completed, even for operations that are normally asynchronous.
      #### Example
      ```
      # Modify the state of all volumes named "simpson" to be offline
      PATCH /api/storage/volumes?name=simpson
      { "state": "offline" }
      ```

    </details>

    <details id="Record_filtering">
      <summary>Record filtering</summary>

      ### Overview
      Records may either be filtered by performing queries that only apply to a single field at a time (though multiple of such queries may be done simultaneously for different fields), or by applying queries that search across a set of fields for a value fulfilling a single specified query.

      ### Filtering records with single field queries
      You can filter the results of a GET call using any attribute. The supplied query can either be for an exact value or can leverage special query operators.
      <br/>
      ```
      <field>=<query value>
      ```

      <br/>Filtering allows you to select objects where the specified field matches the supplied query, or which can contain wildcards, ranges, negations, or an OR-defined list of the above. The special query operators include the following:

      #### Wildcard: `*`
      ```
      abc*
      abc*xyz
      *xyz
      ```
      #### Comparison: `<   >   <=   >=`
      ```
      <10
      >=joe
      ```
      #### Range: `..`
      ```
      3..10
      jim..joe
      ```
      #### Negation: `!`
      ```
      !3
      !joe
      !abc*
      !jim..joe
      ```
      #### Any of a list: `|`
      ```
      3|5
      3|5..9|>100
      ```

      #### Escaping: `{} and ""`
      The special query characters above can be treated literally, with no special meaning, by enclosing the value in either double quotes or curly braces.
      <br/>
      ```
      "joe*"
      {a|b}
      ```

      ### Filtering records with cross-field queries

      Cross-field queries are useful when multiple fields should be searched for a value or some combination of values. Whereas traditional queries only allow a single field to be searched for a value, cross-field queries will return rows where any field in a specified set of fields matches the query. Cross-field queries may only be used for GET requests.
      <br>
      The fields to be queried across are specified in the "query_fields=" parameter. This should be a comma-delimited list of fields, or simply '\*' to search across all fields.
      To specify the query to use in the search, pass in the "query=" parameter to a GET request with the string to use as the query. Fields may also be excluded from searching prefixing with '!'. This is useful if all fields are specified with '*', and then certain fields wish to be excluded, or if an an entire object was queried, to exclude certain sub-fields.

      ### Structure of the query
      The query string represents a pattern to search for in all fields specified.
      <br>
      The '\*' character is used to indicate wildcard character matching. '\*'  matches 0 or more of any character. For a query of "foo*bar", matches will include "foo123abcbar", "foobar", and "foo___123abcbar".
      To search for any match among several possible patterns, the values may be ORed together with the '|' character. For example, to seach for "foo" OR "bar", pass in "query=foo|bar". This may be extended to an arbitrary number of values, such as "query=foo|bar|baz".
      <br>
      Similarly, the query can be used to specify that multiple patterns must be found across all fields specified in "query_fields" for a row to be returned. To specify that multiple patterns must be found, include a space between each one. For example, to search across fields where the fields must contain both "foo" AND "bar", provide "query=foo bar". Again, this may be used on an arbitrary number of patterns. To search for rows that contain all of "foo" AND "bar" AND "baz" within the fields specified, provide "query=foo bar baz".
      <br>
      It should be noted that it is possible for all of the matches to a query to appear in a single field. For example, if "query=foo bar", and a field queried contains "foo bar blah", it will be considered a match. Obviously the queries matches can also be spread across different fields.

      ### Examples
      The following data is used for the examples below:

      | id | name | color | flavor | number | tree |
      | ---|------|-------|--------|--------|----- |
      | 1 | widget1 | blue | chocolate | 1 2 3 | black cherry |
      | 2 | widget2 | red | spinach | three fifty | maple |
      | 3 | widget3 | rainbow | strawberry |  thirty | spruce |
      | 4 | widget4 | brown | strawberry chocolate | thirteen | willow |

      <br>
      <br>
      <b>Request:</b> 'query_fields=color', 'query=red'
      <b>Response:</b>
      | id | name | color | flavor | number | tree |
      | ---|------|-------|--------|--------|----- |
      | 2 | widget3 | red | spinach | three fifty | maple |

      <b>Explanation:</b> The only row with a "color" column matching "red" is row 2.

      <br>
      <br>
      <b>Request:</b> 'query_fields=id,number', 'query=3'
      <b>Response:</b>
      | id | name | color | flavor | number | tree |
      | ---|------|-------|--------|--------|----- |
      | 1 | widget1 | blue | chocolate | 1 2 3 | black cherry |
      | 3 | widget3 | rainbow | strawberry | fourty two | spruce |

      <b>Explanation:</b> Column "id" for row 3 matches the query, and column "number" for number for row 1 matches as well.

      <br>
      <br>
      <b>Request:</b> 'query_fields=flavor', 'query=chocolate|strawberry'
      <b>Response:</b>
      | id | name | color | flavor | number | tree |
      | ---|------|-------|--------|--------|----- |
      | 1 | widget1 | blue | chocolate | 1 2 3 | black cherry |
      | 3 | widget3 | rainbow | strawberry | fourty two | spruce |
      | 4 | widget4 | brown | strawberry chocolate | thirteen | willow |

      <b>Explanation:</b> This query returns rows containing chocolate and/or strawberry in the flavor column. Rows 1, 2, and 4 all contain matches. Row 4 actually matches both queries.

      <br>
      <br>
      <b>Request:</b> 'query_fields=flavor', 'query=chocolate strawberry'
      <b>Response:</b>
      | id | name | color | flavor | number | tree |
      | ---|------|-------|--------|--------|----- |
      | 4 | widget4 | brown | strawberry chocolate | thirteen | willow |

      <b>Explanation:</b> This query returns rows containing chocolate AND strawberry in the flavor column. Only row 4 contains matches for both queries.


      <br>
      <br>
      <b>Request:</b> 'query_fields=name,number', 'query=*3|three'
      <b>Response:</b>
      | id | name | color | flavor | number | tree |
      | ---|------|-------|--------|--------|----- |
      | 1 | widget1 | blue | chocolate | 1 2 3 | black cherry |
      | 2 | widget2 | red | spinach | three fifty | maple |
      | 3 | widget3 | rainbow | strawberry | fourty two | spruce |


      <b>Explanation:</b> Searches across the name and number columns for a value either ending in '3', or containing "three". Row 1 contains 3 in the number field matching the first query, row 3 has a name of "widget3", matching the first query, and row 2 has a number containing three, matching the second query.

      <br>
      <br>
      <b>Request:</b> 'query_fields=*', 'query=1|2|3 th*'
      <b>Response:</b>
      | id | name | color | flavor | number | tree |
      | ---|------|-------|--------|--------|----- |
      | 2 | widget2 | red | spinach | three fifty | maple |
      | 3 | widget3 | rainbow | strawberry |  thirty | spruce |

      <b>Explanation:</b> Searches across all columns, looking for rows where a row both contains either 1 and/or 2 and/or 3, and contains a value starting with "th". Row 1 contains a value matching 1 or 2 or 3, but has no column that begins with th. Similarly, row 4 has a value beginning with "th", but does not contain 1 or 2 or 3. Therefore only rows 2 and 3 are returned, which match both queries.


      <br>
      <br>
      <br>
      ### Cross-Field Query Errors
      - x-ntap-error-table-http-start: common_errors.et,smf_errors.et,rpc_errors.et,rdb.et
      - name: SMF_REST_UNMATCHED_QUOTE
        message: The specified query contains an unmatched quote.
        http: 400
      - name: SMF_REST_CROSS_QUERY_AND_FIELDS
        message: Both 'query_fields' and 'query' must be specified if either one is specified.
        http: 400
      - name: SMF_REST_EMPTY_CROSS_QUERY
        message: The specified query is either empty or is equivalent to an empty query.
        http: 400
      - name: SMF_REST_EMPTY_CROSS_QUERY_FIELDS
        message: At least one field must be specified for the cross-field query.
        http: 400
      - name: SMF_REST_CROSS_QUERY_DUPLICATE
        message: A field was specified twice for the 'query_fields' parameter.
        http: 400
      - name: SMF_REST_EMPTY_CROSS_QUERY
        message: The parameters 'query_fields' and 'query' may only be specified for GET requests.
        http: 400
      - x-ntap-error-table-http-end: END

    </details>

    <details id="Requesting_specific_fields">
      <summary>Requesting specific fields</summary>

      ### Overview
      By default, calling GET on a collection generally returns only the properties that uniquely identify the record, along with a HAL 'self' link to the resource instance. However, you can choose the specific fields you want using the `fields` parameter. The `fields` parameter can also be used with GET when retrieving a single resource instance.
      <br/>For discovery purposes, except for the CLI passthrough, the client can retrieve all standard properties using `fields=\*`. These are the same properties returned when a GET is called on the specific instance using the path keys. However, using `fields=\*` is more expensive than selecting only the specific fields that are needed. In addition, because future releases may include additional properties in this list, or remove properties that were included by default, we strongly discourage using this in client-side software that is depending on specific fields being returned.
      <br/>Some fields are more expensive to retrieve and are not included when using `fields=\*` (or the instance-level GET). These fields are noted in the documentation. They can be returned either by specifying the fields directly, or by using `fields=\*\*`. However, we again strongly discourage this from being encoded into any client-side software. The performance of client software will suffer if a future version of ONTAP adds support for additional expensive properties.
      <br/>
      ```
      fields=<field>[,...]
      ```
      <br/>The `fields` input parameter allows you to specify exactly which fields you want to be returned.

      ### Objects with fields
      When an API contains fields that are objects, an entire object can be specified to return every field within the object. Individual fields within the object can be specified using dotted notation, as demonstrated below. Occasionally, some APIs might not support specifying fields nested within certain objects. Note: Dotted notation for arrays does not include array indices.

      ### Examples
      ```
      {
        "a": "<string>",
        "b": {
          "c": "<string>",
          "d": "<string>"
        },
        "e": [
          {
            "f": "<string1>",
            "g": "<string1>"
          },
          {
            "f": "<string2>",
            "g": "<string2>"
          }
        ]
      }
      ```

      Example `fields` query:
      ```
      fields=a,b     // Fetch a, b.c, and b.d
      fields=a,b.c,e // Fetch a, b.c, e.f, and e.g
      fields=b.d     // Fetch b.d
      fields=e.f     // Fetch e.f
      fields=b,!b.c  // Fetch b.*, but not b.c
      ```

    </details>

    <details id="Records_and_pagination">
      <summary>Records and pagination</summary>

      ### Records
      Several query parameters control the return of records.
      <br/>
      ```
      return_records=<true|false>
      ```
      <br/>The default setting for `return_records` is `true` for GET calls and `false` for all other methods. When `false`, the array of records is not returned.
      <br/>
      ```
      return_timeout=<0..120 seconds>
      ```
      <br/>The `return_timeout` parameter specifies the number of seconds the cluster spends performing an operation before returning. The allowed range is `0` to `120` seconds. If the timeout is reached, GET calls return the records collected along with a pagination link. Other methods return and complete asynchronously. See Non-blocking-operations for more details.
      <br/>The default setting for `return_timeout` is `15` seconds for GET calls. For all other methods it is `0` seconds. This means that these calls might execute asynchronously in order to return as fast as possible.
      <br/>Note: If the `order_by` parameter is specified, the operation might take longer because the collection is sorted before it is returned.
      <br/>
      ```
      max_records=<number of records>
      ```
      <br/>The `max_records` parameter limits the number of records that are returned (or acted on) before providing the "next" pagination link.
      <br/>
      ```
      offset=<offset from the first record>
      ```
      <br/>The `offset` parameter determines how many records to skip over prior to returning the first record.
      <br/>For example, if you have a total of 15 records, and specify an offset of 10, only records 11-15 inclusive will be returned. When combined with a query or sorting specification, the offset will apply after the query or sorting, meaning that you will get records beginning at the Nth record, taking into account the query and sort order. Note that the cost of skipping over N records is likely as great as actually returning those N records.

      ### Pagination
       All calls to GET on a resource collection allow you to page through the results. If the `max_records` parameter is not specified, the cluster returns as many records as possible within the `return_timeout` time threshold. The number of records returned can be further limited by specifying a value for the `max_records` parameter. When the operation reaches either the `return_timeout` or the `max_records` threshold, it stops and returns the records as well as a HAL link that can be used to get the next page of records. It is possible for a pagination link to be returned even if there are no additional records. This occurs because the cluster does not check if there is an additional record before returning when it reaches a threshold. When there are potentially additional records, the response header will also contain a `Link` header containing the link followed by `rel="next"`.
      <br/>The following is an example of the "next" link, which returns with a collection of records:
      <br/>
      ```
      "_links": {
          "next": {
              "href": "/api/storage/aggregates?start.aggregate=aggr25&max_records=25"
          }
      }
      ```
      ### Count only
      The response to collection operations includes a `num_records` field. By passing `return_records=false` with a GET call, you can retrieve the number of records without returning the records themselves. However, if either the `return_timeout` or `max_records` threshold is reached, an incomplete or partial number of records is returned and the "next" link must be called to retrieve additional record counts. All the partial counts must be added together to calculate the total count.

    </details>

    <details id="Record_sorting">
      <summary>Record sorting</summary>

      ### Overview
      By default, records in a collection are returned in the order defined by the object. You can change the order by specifying the `order_by` query parameter. Most uses of the `order_by` parameter collect and reorder _all records_ in the collection. This can be expensive when the collection is large. Therefore, clients are discouraged from paginating through the results with `max_records` when using `order_by`.
      <br/>
      ```
      order_by=<field [asc|desc]>[,...]
      ```

      <br/>If you want to sort on multiple fields (where the prior key value is the same), separate any fields (and optional direction) with a comma.
      <br/>By default, sorting is done in ascending order based on the field type's ordering. If `desc` is specified after a field name, that field is sorted in descending order. Combining this with `max_records` allows you to see the `top` or `bottom` records based on the value of the specified field(s). When using this `top` or `bottom` functionality, queries on certain fields might require more time to search the entire collection regardless of the number of records actually returned.
      <br/>Important Notes:
      * When you use the `order_by` parameter, the `return_timeout` might be exceeded because the collection is sorted before it is returned.
      * Using `order_by` on either a property of type array, or a nested property within an array (not including the records array), returns the records in an unspecified order.
      ### Examples
      ```
      # Sort the volume collection from largest to smallest by size:
      GET /api/storage/volumes?order_by=size desc

      # Find the top 5 applications using the most IOPS:
      GET /api/application/applications?order_by=statistics.iops.total desc,name asc&max_records=5

      # Find the top 10 applications using the most space and then
      # if multiple applications are using the same space, sort them by IOPS:
      GET /api/application/applications?order_by=statistics.space.used desc,statistics.iops.total desc&max_records=10
      ```

    </details>

    <details id="Response_body">
      <summary>Response body</summary>

      ### Overview
      Every API call returns a top-level JSON object. These JSON objects includes GET calls that contain an array of records. This nesting technique allows metadata about the resource or resource collection to be returned as well as each resource instance.
      <br/>GET calls that return an array of records can contain the following top-level elements:
      <br/>
      ```
      {
        "records": [ {}, ... ]
        "num_records": <N>
        "_links": {
          "self": {
            "href": ...
          },
          "next": {
            "href": ...
          }
        }
      }
      ```
      * `records` - The array of records.
      * `num_records` - The number of records in the array.
      * `_links` - Links to relevant APIs, possibly including:
        * `self` - A link to retrieve the same data again.
        * `next` - If there are potentially more records, a link to retrieve the next page of records.

      ### Custom response bodies
      Some APIs might include additional top-level elements. For example, some APIs may include a top-level `errors` array which can include errors if the array of records is incomplete (for reasons other than pagination). See the documentation for each API to check for custom top-level elements.

      ### Error objects
      When an error occurs, an error object is returned in the response body. The `target` element is returned when ONTAP determines the error is due to a specific input field that you've supplied.
      <br/>
      ```
      "error": {
         "message": "<string>",
         "code": <integer>[,
         "target": "<string>"]
      }
      ```
      <br/>

      - x-ntap-error-table-http-start: common_errors.et,smf_errors.et,rpc_errors.et,rdb.et
      - code: 1
        message: An entry with the same identifiers already exists.
        http: 409
      - code: 2
        message: A field has an invalid value, is missing, or an extra field was provided.
        http: 400
      - code: 3
        message: The operation is not supported.
        http: 405
      - code: 4
        message: An entry with the specified identifiers was not found.
        http: 404
      - code: 6
        message: Permission denied.
        http: 403
      - code: 7
        message: Resource limit exceeded.
        http: 503
      - code: 8
        message: Resource in use.
        http: 409
      - name: RPC_ERR_TIMEDOUT
        message: RPC timed out.
        http: 500
      - name: RPC_ERR_FAILED
        message: Generic RPC failure.
        http: 500
      - name: RPC_ERR_CANTCONNECT
        message: Internal RPC error
        http: 500
      - name: SMF_MISSING_VALUE
        message: Missing value.
        http: 400
      - name: SMF_EXTRA_ARG
        message: Unexpected argument. Argument shown in error message body.
        http: 400
      - name: SMF_INVALID_VALUE
        message: Invalid value with value in the body of the error.
        http: 400
      - name: SMF_FIELD_EXCLUDE
        message: A field is used in an invalid context with another field, as shown in error message body.
        http: 400
      - name: SMF_FIELD_SET_TWICE
        message: A field was specified twice. Location of assignments shown in error message body.
        http: 400
      - name: SMF_API_INVALID_VALUE
        message: Invalid value provided for field. Value and field shown in error message body.
        http: 400
      - name: SMF_REST_BODY_EXISTS
        message: A request body is not allowed on GET, HEAD, and DELETE.
        http: 400
      - name: SMF_INVALID_JSON
        message: Invalid JSON with error location provided in body of the error.
        http: 400
      - name: SMF_INVALID_JSON_RANGE
        message: Invalid JSON range, with range provided in the body of the error.
        http: 400
      - name: SMF_INVALID_JSON_UNKNOWN
        message: Invalid JSON due to unknown formatting issue.
        http: 400
      - name: SMF_INVALID_VALUE_REASON
        message: Invalid value with reason provided in body of the error.
        http: 400
      - name: SMF_INVALID_FIELD_VALUE
        message: Invalid value for a field, with value and field in body of the error.
        http: 400
      - name: SMF_MISSING_ASSIGNMENT
        message: A value is missing assignment operator.
        http: 400
      - name: SMF_NOT_EXPECTING_ARRAY
        message: An array was found in the JSON when it was not expected.
        http: 400
      - name: RDB_UNIT_OFFLINE
        message: A node is out of quorum. Body of error message identifies node.
        http: 500
      - name: COMMON_ERRORS_URL_INVALID
        message: A provided URL is invalid.
        http: 400
      - x-ntap-error-table-http-end: END

    </details>

    <details id="Synchronous_and_asynchronous_operations">
      <summary>Synchronous and asynchronous operations</summary>

      ### Overview
      POST, PATCH, or DELETE operations that can take more than `2` seconds are considered _asynchronous_ operations. They are implemented as non-blocking operations. Any API call that is expected to return in less than `2` seconds is considered _synchronous_. Synchronous operations ignore the `return_timeout` parameter.

      ### API response
      If the `return_timeout` is less than the time it takes for an operation to complete, the server returns the code `202 Accepted` after waiting for the specified `return_timeout` seconds. The default `return_timeout` for non-blocking operations is `0` seconds, meaning the operation returns as fast as possible. However, the operation never returns the success code `200 OK`, but instead returns either an error or the code `202 Accepted`.

      ### The Location header
      When a POST operation that is creating a resource returns `201 Created` (synchronous) or `202 Accepted` (asynchronous), the response header includes the `Location` of the resource. For asynchronous operations, a GET call on this resource link may return code `404 Not Found` until the operation successfully completes. Use the returned job link instead of the Location link to determine when the asynchronous operation is complete. POST operations that return code `200 OK` do not populate the Location header.

      ### Tracking non-blocking operations
      Non-blocking or asynchronous operations are executed using _jobs_. The response to a non-blocking operation includes information about the job performing the operation, including a HAL link to the job resource. The job record also includes `state` and `message` fields. The `message` field indicates the progress of the operation while the `state` field indicates `running`. When a job is successful, the `state` and `message` fields indicate `success`. If an operation fails for any reason, the job's `state` reports `error`, and the `message` describes the problem that the operation encountered.
      <br/>For POST operations, when a job is successfully completed, you can use the link from the `Location` header of the original response to retrieve the resource.
      <br/>See [`GET /cluster/jobs`](#/cluster/job_get)<br/>

    </details>

    <details id="HTTP_status_codes">
      <summary>HTTP status codes</summary>

      ### Overview

      The following supported HTTP status codes are returned by ONTAP:

      * 200 OK: Returned for success when not creating a new object
      * 201 Created: Returned for success after the creation of an object
      * 202 Accepted: Returned when a job has been successfully started, but the operation is not complete
      * 400 Bad Request: Returned if the input could not be parsed
      * 401 Unauthorized: Returned if user authentication failed
      * 403 Forbidden: Returned for authorization (RBAC) errors
      * 404 Not Found: Returned when the specified resource does not exist
      * 405 Method Not Allowed: Returned when the specified resource does not support the method (for example, POST or DELETE calls)
      * 409 Conflict: Returned when there is a conflict with a different object that must be created, modified, or deleted before this operation can succeed
      * 500 Internal Error: Returned for most other internal error codes
      * 503 Service Unavailable: Returned if the server is temporarily overloaded. Try again later.

    </details>

    <details id="HTTP_methods">
      <summary>HTTP methods</summary>

      ### Overview

      The ONTAP REST API supports the following HTTP methods:

      * GET: Supported on all collections to retrieve the records
      * POST: When supported, calls on a collection to create the supplied resource
      * PATCH: When supported, calls on a specific resource to update the supplied properties
      * DELETE: When supported, calls on a specific resource to delete the resource
      * HEAD: Supported wherever GET is supported. It makes a GET call, but only returns the HTTP headers
      * OPTIONS: Supported on every endpoint so that you can determine which HTTP methods are supported

    </details>

    <details id="Size_properties">
      <summary>Size properties</summary>

      ### Overview

      Many objects contain properties related to various sizes. Examples can be found in the `aggregate` object, `volume` object, `lun` object and `nvme_namespace` object. These properties are documented as type `integer`.<br/>

      Unless otherwise documented, all sizes are reported in GET in bytes.<br/>

      Depending on the development language-specific code generation, the API typically also requires an integer value in bytes for POST and PATCH input as well.<br/>

      Where a string value is accepted, such as query parameters and ad-hoc curl requests, any of the following suffixes can be used to specify different units:<br/>

      | Suffix | Definition |
      | ------ | ------- |
      | KB | kilobytes (1024 bytes, aka kibibytes) |
      | MB | megabytes (KB x 1024, aka mebibytes) |
      | GB | gigabytes (MB x 1024, aka gibibytes) |
      | TB | terabytes (GB x 1024, aka tebibytes) |
      | PB | petabytes (TB x 1024, aka pebibytes) |

    </details>

    <details id="SVM_tunneling">
      <summary>SVM tunneling</summary>

      ### Overview
      SVM tunneling allows for the scoping of REST APIs to any SVM from the cluster admin SVM interface. The HTTP headers "X-Dot-SVM-Name" and/or "X-Dot-SVM-UUID" are an alternative to supplying svm.name and/or svm.uuid in the request query or body. This allows for setting a context for an HTTP connection and reusing it for multiple calls. The cluster management interface or node management interface can be used instead of the desired SVM's interface. <br/>

      ### Examples
      <br/>Creates a new volume on SVM "vs0":
      ```
      curl  -H "X-Dot-SVM-Name:vs0" -X POST "https://<mgmt-ip>/api/storage/volumes" -d '{"name":"vol1","aggregates":[{"name":"aggr1"}]}'
      {
        "job": {
          "uuid": "b271e19d-c5cb-11e9-b97d-005056ac2211",
          "_links": {
            "self": {
              "href": "/api/cluster/jobs/b271e19d-c5cb-11e9-b97d-005056ac2211"
            }
          }
        }
      }
      ```
      <br/>Retrieves all volumes on SVM "vs0":
      ```
      curl -H "X-Dot-SVM-Name:vs0" -X GET "https://<mgmt-ip>/api/storage/volumes"
      {
        "records":[
         {
           "uuid":"a61e474-929a-4c78-882a-b72986ccf276",
           "name":"root_vs0",
           "_links":{
             "self":{
               "href":"/api/storage/volumes/aa61e474-929a-4c78-882a-b72986ccf276"
             }
           }
         },
         {
           "uuid":"b26c64f5-c5cb-11e9-b97d-005056ac2211",
           "name":"vol1",
           "_links":{
             "self":{
               "href":"/api/storage/volumes/b26c64f5-c5cb-11e9-b97d-005056ac2211"
             }
           }
         }
       ],
       "num_records": 2,
       "_links": {
         "self":{
           "href":"/api/storage/volumes"
          }
        }
       }
      ```
      <br/>Deletes a volume on SVM "vs0" using the X-Dot-SVM-UUID header:
      ```
      curl -H "X-Dot-SVM-UUID:85ebedff-c43e-11e9-bc27-005056ac2211" -X DELETE "https://<mgmt-ip>/api/storage/volumes?name=vol1"
      {
        "jobs":[
          {
            "uuid":"4acf3f58-c5d2-11e9-b97d-005056ac2211",
            "_links":{
              "self":{
                "href":"/api/cluster/jobs/4acf3f58-c5d2-11e9-b97d-005056ac2211"
              }
            }
          }
        ],
        "num_records": 1,
        "_links":{
          "self":{
            "href":"/api/storage/volumes?name=vol1"
          }
        }
      }
      ```
      <br/>Retrieves all IP interfaces on SVM "vs3":
      ```
      curl -H "accept: application/json" -H "X-Dot-SVM-Name:vs3" -X GET "https://<mgmt-ip>/api/network/ip/interfaces"
      {
        "records":[
          {
            "uuid":"83aeeac9-c5d8-11e9-b97d-005056ac2211",
            "name": "vs3_data_1"
          },
          {
            "uuid":"9c612bc0-c5a5-11e9-b97d-005056ac2211",
            "name":"vs3_data"
          }
        ],
        "num_records": 2
      }
      ```

    </details>

    <details id="Using_the_private_CLI_passthrough_with_the_ONTAP_REST_API">
      <summary>Using the private CLI passthrough with the ONTAP REST API</summary>

      ### REST API access to CLI commands
      To help CLI and ONTAP users transition to the ONTAP REST API, ONTAP provides a private REST API endpoint that can be used to access any CLI command. Usage of this API call is recorded and returned in the AutoSupport data collection so that NetApp can identify usablity and functionality improvements in the REST API for future releases. There is no per-API documentation for the REST API access for each CLI command. Unlike the documented REST APIs, the API paths and properties for the CLI passthrough correspond very closely to the CLI. There are several rules that govern all the differences between a CLI command and the REST API mirroring the CLI command.

      #### Rules for path differences when accessing a CLI command through the REST API
      The API paths mirror the CLI paths, except for the use of the "show", "create", "modify", and "delete" verbs. Instead of using these four CLI verbs in the REST API, the corresponding HTTP methods must be used (GET, POST, PATCH, and DELETE). The four CLI verbs are removed from the API path supporting a command. For any commands where the last verb is hyphenated and begins with one of these verbs (for example, "show-space" or "delete-all"), you must remove the verb and following hyphen from the path. Any space in a full command path becomes a forward slash in the REST API (for example, "system node" becomes "/api/private/cli/system/node"). For non-show CLI commands that use non-standard verbs, the POST method should be used on the full path with the final verb in the API path. For example, "volume rehost" becomes "POST /api/private/cli/volume/rehost" and "cluster add-node" becomes "POST /api/private/cli/cluster/add-node".
      <br/>To know which HTTP methods are supported for an API call, both documented and CLI-based, clients can use the "OPTIONS" HTTP method. For example, using OPTIONS on "/api/private/cli/volume" returns 'OK' with the HTTP "Allow" header containing a list of the supported HTTP methods (for example, "Allow: GET, HEAD, OPTIONS, POST, DELETE, PATCH"). For feature-specific CLI verbs, you can use OPTIONS on the API path. For example, using OPTIONS on "/api/private/cli/volume/restrict" returns with the HTTP header "Allow: OPTIONS, POST". Some of the CLI "show" commands do not contain the standard verb. For example, calling OPTIONS on "/api/private/cli/cluster/add-node-status" returns "Allow: GET, HEAD, OPTIONS".
      <br/>There are some commands in the CLI that will not work using REST APIs. This includes most show commands that do not support "show -fields" in the CLI. The REST API also does not support CLI commands that create a new shell (like "run" and "vserver context").
      <br/>Here are several examples of mappings from the ONTAP CLI to the ONTAP REST API for the /api/private/cli path:
      * volume show       &rarr; GET /api/private/cli/volume
      * volume create     &rarr; POST /api/private/cli/volume
      * volume modify     &rarr; PATCH /api/private/cli/volume
      * volume delete     &rarr; DELETE /api/private/cli/volume
      * volume restrict   &rarr; POST /api/private/cli/volume/restrict
      * volume show-space        &rarr; GET /api/private/cli/volume/space
      * volume show-footprint    &rarr; GET /api/private/cli/volume/footprint
      * cluster add-node         &rarr; POST /api/private/cli/cluster/add-node
      * cluster add-node-status  &rarr; GET /api/private/cli/system/node/add-node-status
      * system node coredump show       &rarr; GET /api/private/cli/system/node/coredump
      * system node coredump delete     &rarr; DELETE /api/private/cli/system/node/coredump
      * system node coredump delete-all &rarr; DELETE /api/private/cli/system/node/coredump/all

      #### Rules for field differences when accessing a CLI command through the REST API
      All CLI parameters are supported in the CLI-based REST APIs. However, REST converts hyphens (-) in CLI parameter names to underscores (_) in the REST API JSON response body. In general, REST API responses use the same formatting for property values as ONTAPI. For example, enumerated values are formatted in lowercase instead of uppercase and with underscores instead of hyphens in the REST API response body. Both CLI and ONTAPI formats are allowed on input. Also similar to ONTAPI, sizes and percentages in REST are encoded as integers in bytes. Unlike ONTAPI or the CLI, date and time values in REST are encoded with the ISO-8601 format. All fields that you want returned from the GET call must be specified using the `fields` parameter. Note that the /api/private/cli/... APIs do not support "fields=*".

      ### Examples
      Retrieve OPTIONS for volumes endpoint (with results contained in header):
      ```
      curl -X OPTIONS "https://<mgmt-ip>/api/private/cli/volume" --include
      Allow: GET, HEAD, OPTIONS, POST, DELETE, PATCH
      {
      }
      ```
      <br>GET size and percent-used for all volumes:
      ```
      curl -X GET "https://<mgmt-ip>/api/private/cli/volume?fields=size,percent-used&pretty=false"
      {
        "records": [
          { "vserver": "vs1", "volume": "vol1", "size": 20971520, "percent_used": 73 },
          { "vserver": "vs1", "volume": "vol2", "size": 20971520, "percent_used": 87 },
          ...
        ]
      }
      ```
      <br>GET size and percent-used for a specific volume:
      ```
      curl -X GET "https://<mgmt-ip>/api/private/cli/volume?volume=vol2&pretty=false"
      {
        "records": [
          { "vserver": "vs1", "volume": "vol2", "size": 209715203864, "percent_used": 89 },
          ...
        ]
      }
      ```
      <br>POST a new volume with all required attributes:
      ```
      curl -X POST "https://<mgmt-ip>/api/private/cli/volume" -d '{"volume":"vol3","vserver":"vs0","aggregate":"aggr1"}'
      {
        "job": {
          "uuid": "f7b5f5cb-54a2-11e9-930a-005056ac6a3f",
          "_links": {
            "self": {
              "href": "/api/cluster/jobs/f7b5f5cb-54a2-11e9-930a-005056ac6a3f"
            }
          }
        },
        "cli_output": "[Job 36] Job is queued: Create vol2."
      }
      ```
      <br>Attempt to DELETE an online volume:
      ```
      curl -X DELETE "https://<mgmt-ip>/api/private/cli/volume?vserver=vs1&volume=vol1"
      {
        "num_records": 0,
        "error: {
          "message": "Volume vol1 in Vserver vs1 must be offline to be deleted.",
          "code": "917658"
        }
      }
      ```
      <br>PATCH a volume to become offline:
      ```
      curl -X PATCH "https://<mgmt-ip>/api/private/cli/volume?vserver=vs1&volume=vol1" -d '{ "state": "offline" }'
      {
        "num_records": 1,
        "cli_output: "Volume modify successful on volume vol1 of Vserver vs1.\n"
      }
      ```
      <br>DELETE the offline volume:
      ```
      curl -X DELETE "https://<mgmt-ip>/api/private/cli/volume?vserver=vs1&volume=vol1"
      {
        "jobs": [
          {
            "uuid": "3f35a934-4b40-11e9-9f4d-005056bbf4eb",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/3f35a934-4b40-11e9-9f4d-005056bbf4eb"
              }
            }
          }
        ],
        "num_records": 1,
        "cli_output": "[Job 1243] Job succeeded: Successful\n"
      }
      ```
      Note: When POST is called for a command that uses a job, the REST API does not wait for the job to complete, unless `return_timeout` is specified. However, PATCH and DELETE calls on the command path (using queries on key fields in the query portion of the URI) wait up to 15 seconds for the operation to complete if the `return_timeout` parameter is not specified.
      <br>DELETE an offline volume without waiting:
      ```
      curl -X DELETE "https://<mgmt-ip>/api/private/cli/volume?vserver=vs1&volume=vol2&return_timeout=0"
      {
        "jobs": [
          {
            "uuid": "a7138c5e-4b69-11e9-9f4d-005056bbf4eb",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/a7138c5e-4b69-11e9-9f4d-005056bbf4eb",
              }
            }
          }
        ],
        "num_records": 1,
        "cli_output": "[Job 1247] Job is queued: Delete vol1.\n"
      }
      ```

      ### CLI message output
      As shown in the previous example, any non-field and non-error based output that would have appeared in the CLI is returned in a top-level `cli_output` attribute in the response body. This does not contain normal CLI headers or field values. It only displays messages that were printed to the CLI.

      ### HTTP status codes
      Error codes in the response body are mapped to the most appropriate HTTP status codes. In cases where this is not done, the HTTP status code defaults to 500. This does not necessarily indicate that the error is internal to ONTAP.


      ### Security
      All CLI-based REST APIs are RBAC-controlled, based on the role of the authenticated user and have the same protections they have in the CLI.

      ### Location of CLI fields for CLI-based REST APIs:
      * POST APIs: All CLI fields must be provided in the request body.
      * GET APIs: All desired CLI fields (except keys) must be specified in the `fields` parameter. The non-key fields returned via the CLI will not be returned if not requested. The client can also provide a query for any field.
      * PATCH APIs: The client can provide a query for any field, but at least one field must have a query. To modify only a single record, all CLI keys must contain an exact query. All new values for the object must be provided in the request body.
      * DELETE APIs: The client can provide a query for any field, but at least one field must have a query. To delete only a single record, all CLI keys must contain an exact query. Non-attribute inputs (such as `force`) must be provided in the query portion of the URI.

    </details>

basePath: /api

schemes:
  - https

consumes:
  - application/json
  - application/hal+json

produces:
  - application/json
  - application/hal+json

tags:
  - name: cloud
    description: Manages cloud (object storage) targets
  - name: cluster
    description: |
      Manages clusters, nodes, jobs, and cluster software
    x-ntap-long-description: |
      ## Overview
      These APIs enable you to perform a number of independent workflows, including:
      * Creating the cluster
      * Adding nodes to the cluster
      * Managing cluster configuration data (including name, version, NTP servers, name servers, and DNS domains)
      * Managing node configuration data (including node names, models, serial numbers, and HA group information)
      * Discovering the nodes on the cluster network that can be added to the cluster
      * Viewing and updating current and recent jobs
      * Updating the cluster software

      ### Pre-Cluster APIs
      A few of the cluster APIs (namely, POST/OPTIONS on /api/cluster, GET/HEAD/OPTIONS on /api/cluster/nodes, and calls on /api/cluster/jobs) are allowed before the cluster is created.  These APIs support creation of the cluster and monitoring of its progress. Any other cluster API used before the cluster is created will fail.

  - name: networking
    description: Manages physical and logical networking
    x-ntap-long-description: |
      ## Overview
      The ONTAP networking APIs enable reporting on networking information, such as IPspaces, interfaces, routes, ports, service policies and broadcast domains. Some can also be used to manage networking.
      <br/>
      ---

      ## IPspaces
      IPspaces enable you to configure a single ONTAP cluster so that it can be accessed by clients from more than one administratively separate network domain, even if those clients are using the same IP address subnet range. This allows for separation of client traffic for privacy and security.<br/>

      An IPspace defines a distinct IP address space in which storage virtual machines (SVMs) reside. Ports and IP addresses defined for an IPspace are applicable only within that IPspace. A distinct routing table is maintained for each SVM within an IPspace, so that no cross-SVM or cross-IPspace traffic routing occurs.
      <br/>

      ---

      ## Ethernet
      ### Broadcast Domains
      A broadcast domain is a set of ports which would all receive a broadcast packet that is sent from any of the ports.<br/>

      By accurately representing the physical network with an ONTAP broadcast domain, ONTAP ensures that IP interfaces are able to migrate to appropriate ports in case of failure. ONTAP also ensures that characteristics, such as MTU, stay matched across all ports of the broadcast domain.<br/>

      A broadcast domain resides in an IPspace, and can be used by cluster-scoped or SVM-scoped IP interfaces in that IPspace. The scope of the broadcast domain's uniqueness is the IPspace it is in. You must create as many broadcast domains in an IPspace as there are IP subnets with interfaces in that IPspace.<br/>

      Ports are mapped to an IPspace by assigning the port's broadcast domain.

      ### Ports
      A port is a physical or virtual Ethernet network device. Physical ports may be combined into Link Aggregation Groups (LAGs, or ifgrps), or divided into Virtual LANs (VLANs).<br/>

      The GET and PATCH APIs are available for all port types. The POST and DELETE APIs are available for "lag" and "vlan" port types.<br/>

      A given port can host zero or more IP interfaces.<br/>

      A port exists in a broadcast domain and all ports within the same broadcast domain must have layer 2 network connectivity to one another. If a port within a broadcast domain goes down, any IP interfaces hosted by that port can fail over to other ports in the same broadcast domain.
       <br/>
      ---

      ## Fibre Channel

      ### Interfaces
      Fibre Channel (FC) interfaces are the logical endpoints for Fibre Channel network connections to an SVM. A Fibre Channel interface provides Fibre Channel access to storage within the interface's SVM using either Fibre Channel Protocol (FCP) or Non-Volatile Memory Express over Fibre Channel (NVMe over FC).<br/>

      The Fibre Channel interface REST API allows you to create, delete, update and discover Fibre Channel interfaces and obtain status information for Fibre Channel interfaces.<br/>

      A Fibre Channel interface is created on a Fibre Channel port that is located on a cluster node. The Fibre Channel port must be specified to identify the location of the interface for a POST or PATCH that relocates an interface. You can identify the port by either supplying the node and port names or the port UUID.

      ### Ports
      Fibre Channel ports are the physical ports of Fibre Channel adapters on ONTAP cluster nodes that can be connected to Fibre Channel networks to provide Fibre Channel network connectivity. A Fibre Channel port defines the location of a Fibre Channel interface within the ONTAP cluster.<br/>

      The Fibre Channel port REST API allows you to discover Fibre Channel ports, obtain status information for Fibre Channel ports, and configure Fibre Channel port properties.

      ### Learn More
      * _Fibre Channel Logins_ found in both the _SAN_ and _NVMe_ sections. Fibre Channel logins represent connections formed by Fibre Channel initiators that have successfully logged in to ONTAP.

      ---

      ## IP
      ### Interfaces
      An interface (also referred to as a _LIF_ in ONTAP documentation) represents a network access point to a node in a cluster. In other words, an interface is essentially an IPv4 or IPv6 address with associated attributes.<br/>

      IP interfaces are configured on ports to send and receive communications over the network. The port that will host the interface can either be explicitly specified using node and/or port fields or implicitly specified using a broadcast domain.<br/>

      The IPspace of the interface is required for cluster-scoped interfaces. The SVM owning the interface is required for SVM-scoped interfaces. These interfaces are in the SVM's IPspace.<br/>

      The service policy of an interface defines what network services are provided by the interface.

      ### Routes
      Routes indicate which IPv4 or IPv6 gateway to use to communicate with hosts that are not on the local subnet. Typically, an IP interface (or LIF) can only use a gateway if it has the same address family and is in the LIF's subnet.<br/>

      It is important that every gateway address belongs to a physical or virtual router that has connectivity to the specified destination network.<br/>

      SVM-scoped routes can only be used by IP interfaces of the specified SVM. Likewise, cluster-scoped routes can only be used by cluster-scoped IP interfaces in the specified IPspace.

      ### Service Policies
      Service policies are named groupings that define what services are supported by an IP interface. These include both built-in service policies (for example: default-data-files or default-management) and custom service policies.<br/>

      Service policies are scoped to either an SVM or IPspace.
      <br/>
      ---

  - name: svm
    description: Manages storage virtual machines (SVMs)
    x-ntap-long-description: |
      ## Overview
      Storage Virtual Machine (SVM) APIs enable you to manage SVMs and their attributes, including the configuration of the CIFS and NFS protocols, export policies, name mappings between CIFS and NFS users, and network services.
      <br/>SVMs contain data volumes and one or more network interfaces through which they serve data to the clients. SVMs securely isolate the shared virtualized data storage and network, and each SVM appears as a single dedicated server to the clients. Each SVM has a separate administrator authentication domain, and each SVM can be managed independently by its SVM administrator.
      <br/>In a cluster, SVMs facilitate data access. A cluster must have at least one SVM to serve data. Multiple SVMs can coexist in a single cluster without being bound to any particular node in the cluster. However, they are bound to the physical cluster on which they exist.
      <br/>SVMs with volumes can contain files and LUNs. They provide file-level data access by using NFS and CIFS protocols for the NAS clients, and block-level data access by using iSCSI and Fibre Channel (FC) (FCoE included) for SAN hosts. The volumes within each NAS SVM are related to each other through junctions and they are mounted on junction paths. These junctions present the file system in each volume. The root volume of the SVM resides at the top level of the namespace hierarchy; additional volumes are mounted to the SVM root volume to extend the namespace. As volumes are created for the SVM, the root volume of the SVM contains junction paths.
      <br/>The ONTAP REST APIs only expose data SVMs as an SVM. The information and configuration associated with the cluster and nodes are exposed from REST, but the cluster and nodes are not treated as if they are a type of SVM from REST APIs. Some APIs that expose both cluster-owned resources and SVM-owned resources from the same endpoint only return and support the "svm" sub-object for the resources that are within a data SVM. In those endpoints, the resources that are not in a data SVM do not return the "svm" sub-object. Generally, such endpoints have a "scope" attribute that returns either "svm" or "cluster" to identify the resource as either a cluster-level resource or one that is completely contained in a data SVM.

  - name: name-services
    description: Manages SVM name services such as LDAP, NIS, and DNS
    x-ntap-long-description: |
      ## Overview
      ONTAP uses name-services to obtain information about users and clients. This information is used to authenticate users accessing data on or administering the storage system, and to map user credentials in a mixed environment. If the user database is stored in NIS or LDAP servers, NIS and LDAP name services need to be configured in ONTAP.
      DNS is used for resolving the hostnames. ns-switch is used to configure the SVMs with sources to search for network information and the order in which to search them.

  - name: SAN
    description: Manages resources for storage area networks (SAN)
    x-ntap-long-description: |
      ## Overview

      The storage area network (SAN) endpoints and objects enable you to configure, provision, and manage SAN-related objects.

      <br/>
      ---
      ## Fibre Channel

      ### Logins
      Fibre Channel logins represent connections, formed by Fibre Channel initiators, that have successfully logged in to ONTAP. This represents the Fibre Channel login on which higher-level protocols, such as Fibre Channel Protocol (FCP) and Non-Volatile Memory Express over Fibre Channel (NVMe over FC), rely.<br/>

      The Fibre Channel logins REST API provides information about active Fibre Channel logins.

      ### WWPN Aliases
      A WWPN (world wide port name) is a unique 64-bit identifier for a Fibre Channel initiator. It is displayed as a 16-character hexadecimal value. SAN administrators may find it easier to identify Fibre Channel initiators using an alias, especially in larger SANs.<br/>

      The WWPN alias REST API allows you to create, delete and discover aliases for WWPNs.

      ### Services
      A Fibre Channel Protocol (FCP) service defines the properties of the Fibre Channel Protocol target for an SVM. There can be at most one FCP service for a given SVM. An SVM's FCP service must be created before FCP initiators can login to the SVM.<br/>

      The Fibre Channel Proctocol (FCP) service REST API allows you to create, update, delete, and discover Fibre Channel Services for SVMs.
      Fibre Channel interfaces are the logical endpoints for Fibre Channel network connections to an SVM.

      ---
      ## iSCSI

      ### Credentials
      An iSCSI credentials object defines the authentication credentials to be used between an iSCSI initiator and ONTAP. It identifies an authentication type, user names, and the passwords that must be used to authenticate a specific initiator.<br/>

      The iSCSI credentials REST API allows you to create, update, delete, and discover iSCSI credential objects.

      ### Services
      An iSCSI service defines the properties of the iSCSI target for an SVM. There can be at most one iSCSI service for an SVM. An SVM's iSCSI service must be created before iSCSI initiators can login to the SVM.<br/>

      The iSCSI service REST API allows you to create, update, delete, and discover iSCSI services for SVMs.

      ### Sessions
      An iSCSI session consists of one or more TCP connections that link an iSCSI initiator with an iSCSI target. TCP connections can be added and removed from an iSCSI session by the iSCSI initiator. Across all TCP connections within an iSCSI session, an initiator sees one and the same target. After the connection is established, iSCSI control, data, and status messages are communicated over the session.<br/>

      The iSCSI sessions REST API provides information about iSCSI initiators that have successfully logged in to ONTAP.

      ### Learn More
      * _IP Interfaces_ found in the _networking_ section. IP interfaces are the logical endpoints for iSCSI network connections to an SVM.

      ---

      ## Initiator Groups
      An initiator group (igroup) is a collection of Fibre Channel WWPNs (world wide port names), iSCSI IQNs (qualified names), iSCSI EUIs (extended unique identifiers), or any combination of these, that identify host initiators.<br/>

      Initiator groups are used to control which hosts can access specific LUNs. To grant access to a LUN from one or more hosts, a network administrator creates an initiator group containing the hosts' initiator names, and then creates a LUN map that associates the initiator group with the LUN.<br/>

      The initator group REST API allows you to create, update, delete, and discover initiator groups. It also enables you to add and remove initiators that can access the target and associated LUNs.

      ## LUN Maps
      A LUN map is an association between a LUN and an initiator group. When a LUN is mapped to an initiator group, the group's initiators are granted access to the LUN. The relationship between an initiator group and a LUN is many initiator groups to many LUNs.<br/>

      The LUN map REST API allows you to create, delete, and discover LUN maps.

      ## LUNs
      A LUN is the logical representation of storage in a storage area network (SAN).<br/>

      The LUN REST API allows you to create, update, delete, and discover LUNs.

  - name: NVMe
    description: Manages resources for Non-Volatile Memory Express (NVMe)
    # add to Learn More when we restore interface_type and support IP NVMe
    # * _IP Interfaces_ found in the _networking_ section. IP interfaces are the logical endpoints for iSCSI network connections to an SVM.
    x-ntap-long-description: |
      ## Overview

      The Non-Volatile Memory Express (NVMe) API endpoints and objects provide for configuration, provisioning and management of the NVMe-related objects.

      NVMe over Fabrics (NVMe-oF) refers to the extensions and changes to the base NVMe command set to support NVMe commands over a fabric interconnect and from multiple hosts simultaneously. ONTAP implements elements of both NVMe and NVMe-oF. Throughout this documentation, NVMe is generally used to refer to both NVMe and NVMe-oF.

      ### Fibre Channel Logins
      Fibre Channel logins represent connections, formed by Fibre Channel initiators, that have successfully logged in to ONTAP. This represents the Fibre Channel login on which higher-level protocols such as Fibre Channel Protocol (FCP) and Non-Volatile Memory Express over Fibre Channel (NVMe over FC) rely.<br/>

      The Fibre Channel logins REST API provides information about active Fibre Channel logins.

      ### NVMe Interfaces
      NVMe interfaces are network interfaces configured to support an NVMe over Fabrics protocol. The NVMe interfaces are Fibre Channel interfaces supporting an NVMe-oF data protocol. Regardless of the underlying physical and data protocol, NVMe interfaces are treated equally for the host-side application configuration. This endpoint provides a consolidated view of all NVMe interfaces for the purpose of configuring host-side applications.<br/>

      The NVMe interfaces REST API provides NVMe-specific information about network interfaces configured to support an NVMe-oF protocol.

      #### Learn More
      * _Fibre Channel Interfaces_ found in the _networking_ section. Fibre Channel interfaces are the logical endpoints for Fibre Channel network connections to an SVM.

      ### NVMe Services
      A Non-Volatile Memory Express (NVMe) service defines the properties of the NVMe controller target for an SVM. There can be at most one NVMe service for a given SVM. An SVM's NVMe service must be created before NVMe host initiators can connect to the SVM.<br/>

      The Non-Volatile Memory Express (NVMe) service REST API allows you to create, update, delete, and discover NVMe services for SVMs.

      ### NVMe Subsystem Controllers
      Non-Volatile Memory Express (NVMe) subsystem controllers represent dynamic connections between hosts and a storage solution.<br/>

      The NVMe subsystem controllers REST API provides information about connected hosts.

      ### NVMe Subsystem Maps
      An NVMe subsystem map is an association of an NVMe namespace with an NVMe subsystem. When an NVMe namespace is mapped to an NVMe subsystem, the NVMe subsystem's hosts are granted access to the NVMe namespace. The relationship between an NVMe subsystem and an NVMe namespace is one subsystem to many namespaces.<br/>

      The NVMe subsystem map REST API allows you to create, delete, and discover NVMe subsystem maps.

      ### NVMe Subsystems
      An NVMe subsystem maintains configuration state and namespace access control for a set of NVMe-connected hosts.<br/>

      The NVMe subsystem REST API allows you to create, update, delete, and discover NVMe subsystems. It also allows you to add and remove NVMe hosts that can access the subsystem and associated namespaces.

      ### NVMe Namespaces
      An NVMe namespace is a collection of addressable logical blocks presented to hosts connected to the storage virtual machine using the NVMe over Fabrics protocol.<br/>

      The NVMe namespace REST API allows you to create, update, delete, and discover NVMe namespaces.

  - name: application
    description: Manages applications
    x-ntap-long-description: |
      ## Overview
      ONTAP application APIs simplify storage management by using terminology specific to a type of application. This application-specific terminology can be used to provision and manage ONTAP storage objects. A single call using application-specific parameters provisions storage and enables protocol access for an application following NetApp best practices. You can view and manage the ONTAP objects making up the application as a group using the application APIs. The library of available application templates already includes several database and virtualization applications.

      ## APIs

      There are several application APIs that must be used to fully manage an application. Templates are used to represent any parameters specific to a given application. Some APIs expose applications in terms of their specific template, while others only expose a generic view that all applications share. The template view is present on the _templates_ and _applications_ APIs (although these APIs do also include some generic fields). The _components_ and _snapshots_ APIs are entirely generic and do not differ across types of applications.
      <br/>The following section provides an overview of each API, followed by a lifecycle example of managing an application to demonstrate how the APIs can be used together.

      ***
      ### Template
      A template is an ONTAP representation of a specific type of application. Each template represents one type of application, the parameters that can be used to customize it, the layout of its storage, and how it can be accessed. Templates are intended to expose an application in terms specifically applicable to an administrator of a given application. As such, traditional ONTAP storage elements are generally not included in an application template.
      <br/>The template APIs can be used to discover what templates are currently available. The ONTAP API documentation also includes a model of the templates. The template APIs generally provide the same information as the documentation, but the template APIs might provide more up-to-date details about the default values of template parameters based on the current ONTAP configuration. However, only the ONTAP API documentation includes a full description of each template parameter, its usage, and whether it is optional.
      ***
      ### Application
      The application APIs are the only interfaces that allow management of an application using template properties.
      <br/>The application object includes the following three sections:

      1. Generic metadata about the application, including common fields such as the name of the application, the template used to provision it, and the generation number of the application.
      2. Statistics information about the application, including space and IOPS details about the entire application and each of its components. These are expensive to collect and should only be requested when needed using a _fields=_ query.
      3. A template view of the application. The application object itself presents a mutually exclusive list of all possible templates. Only one of these fields can be used per application. The name of the field corresponds to the name of the template used by the application. Currently, the creation of a new application and the modification of the storage service for an existing application are supported through the template parameters.
      ***
      ### Component
      The component API offers a generic view of the application and how to access the application from the host application. This is the only API that exposes the underlying ONTAP storage elements of which the application is composed. It is read-only; it cannot support modifications specific to the type of application it is presenting.
      <br/>The component object includes the following details for an application:

      1. The NFS export rules for accessing the application from the host.
      2. The CIFS share and users that can access the application from the host.
      3. The SAN initiators that can access the application from the host.
      4. For IP-based protocols, the IP addresses that are best suited for accessing the component.
      5. The underlying storage elements that make up the component, such as volumes or LUNs.

      ***
      ### Snapshot copy
      The Snapshot copy APIs offer full CRUD for application-level Snapshot copies. Application Snapshot copies can be flagged as either crash-consistent or application-consistent. From the perspective of ONTAP, there is no difference between the two. It is the responsibility of the administrator to ensure that the application is in a consistent state before flagging a Snapshot copy as application-consistent. Use of the SnapCenter Backup Management suite is recommended to ensure correct interaction between host applications and ONTAP.
      ***
      ## Example

      The following example outlines the APIs necessary to manage applications and how they fit together. However, this example does not provide detailed information on each API. See the documentation for the individual APIs for more information.

      ### 1) Discover the templates

      This documentation, which includes the model of each template as part of the _templates_ and _applications_ APIs, is the easiest and most comprehensive way to discover the available templates. The _templates_ API can also be used to query the system for templates in a programmatic way.<br/>

      To discover the templates available to provision an Oracle application, the following query is used.
      ---
      ```
      # The API:
      /api/application/templates

      # The query:
      name=oracle*

      # The call:
      curl -X GET "https://<mgmt-ip>/api/application/templates?name=oracle*" -H "accept: application/json"

      # The response:
      {
        "records": [
          {
            "name": "oracle_on_nfs", "description": "Oracle using NFS."
          },
          {
            "name": "oracle_on_san", "description": "Oracle using SAN."
          },
          {
            "name": "oracle_rac_on_nfs", "description": "Oracle RAC using NFS."
          },
          {
            "name": "oracle_rac_on_san", "description": "Oracle RAC using SAN."
          }
        ],
        "num_records": 4
      }
      ```
      ---

      ### 2) Create an application

      Now that we know the possible templates, we use one to create an application. The template properties differ from template to template, and can be found by exploring the model of the application object in this documentation. Each call to create an application must include the properties for exactly one template. These properties are provided under the property with the same name as the template. Other than the template properties, the only other required properties to create an application are the SVM and name.
      <br/>Note: In the following call example, not all of the template properties are included. Where a property is not needed or the default is sufficient, the property can be excluded. In this case using the _oracle_on_nfs_ template, the _archive_log_, and _protection_type_ are not included. The template name, _oracle_on_nfs_, is specified above the group of template properties, after the names of the application and the SVM.
      <br/>Creating an application is asynchronous, so the response for this API includes information about the job doing the work. The response header also includes the _location_ of where the application can be found if the job is successful.

      ---
      Prior to creating an application, the following prerequisites must be met for the protocols associated with the template:
      * Licences must be installed.
        * [`POST /cluster/licensing/licenses`](#cluster/license_create)
      * Aggregates must exist with enough available space and IOPS to satisfy the requested size.
        * [`POST /storage/aggregates`](#storage/aggregate_create)
      * An SVM must exist with protocol services enabled.
        * [`POST /svm/svms`](#svm/svm_create)
      * LIFs must exist. For SAN applications, only High Availability groups where each node has at least on LIF will be considered for placement of storage objects.
        * [`POST /network/ip/interfaces`](#networking/network_ip_interfaces_create)
        * [`POST /network/fc/interfaces`](#networking/fc_interface_create)
      ---
      The following are not required prior to creating an application, but might be necessary before connecting to the application:
      * Network routes must be created to access ethernet based LIFs.
        * [`POST /network/ip/routes`](#networking/network_ip_routes_create)
      * For volumes created by this operation to be successfully mounted, ONTAP requirements related to mounting must be met.
      ---
      ```
      # The API:
      /api/application/applications

      # The query:
      No query is needed for this command. Optionally, you can specify the return_timeout or set the return_records flag to alter the behavior of the command.

      # The body:
      {
        "name": "my_ora_app",
        "svm": {
          "name": "svm1"
        },
        "oracle_on_nfs": {
          "db": {
            "size": "2GB",
            "storage_service": {
              "name": "value"
            },
            "nfs_access": [
                {
                    "access": "rw",
                    "host": "0.0.0.0/0"
                }
            ]
          },
          "redo_log": {
            "size": "1GB"
          },
          "ora_home": {
            "size": "1GB"
          }
        }
      }

      # The call:
            curl -X POST "https://<mgmt-ip>/api/application/applications" -H "accept: application/hal+json" -H "content-type: application/json" -d '{ "name": "my_ora_app", "svm": { "name": "vs1" }, "oracle_on_nfs": { "db": { "size": "2GB", "storage_service": { "name": "value" }, "nfs_access": [ { "access": "rw", "host": "0.0.0.0/0" } ] }, "redo_log": { "size": "1GB" }, "ora_home": { "size": "1GB" } } }'

      # The response:
      {
        "job": {
          "uuid": "dc0d01dd-df5a-11e7-b5d2-005056b47eb2",
          "id": 94,
          "_links": {
            "self": {
              "href": "/api/cluster/jobs/dc0d01dd-df5a-11e7-b5d2-005056b47eb2"
            }
          }
        }
      }

      # The response header:
      date: Tue, 12 Dec 2017 16:38:18 GMT
      server: libzapid-httpd
      content-type: application/hal+json
      location: /api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2
      cache-control: no-cache,no-store,must-revalidate
      connection: Keep-Alive
      keep-alive: timeout=5, max=100
      content-length: 203
      ```
      ---

      ### 3) Wait for the application to be created

      The call to create the application returns information about the job, including a HAL link to retrieve details about the job. The job object includes a state and a message to indicate the progress of the job. When the job is complete, and the application has been fully created, the message indicates success and the _state_ of the job property is _success_.
      <br/>For brevity purposes, the successful job response is shown here. On a real cluster, an application might take several seconds to several minutes to be created, depending on the system load. If the job is not complete, the _message_ property includes a short description on the progress of the job, and the _state_ indicates _running_.

      ---
      ```
      # The API:
      /api/cluster/jobs/{uuid}

      # The call, provided by the HAL link from step 3:
      curl -X GET "https://<mgmt-ip>/api/cluster/jobs/dc0d01dd-df5a-11e7-b5d2-005056b47eb2" -H "accept: application/hal+json"

      # The response:
      {
        "uuid": "dc0d01dd-df5a-11e7-b5d2-005056b47eb2",
        "state": "success",
        "message": "Complete: Success [0]",
        "code": 0,
        "_links": {
          "self": {
            "href": "/api/cluster/jobs/dc0d01dd-df5a-11e7-b5d2-005056b47eb2"
          }
        }
      }
      ```
      ---

      ### 4) Retrieve the new application

      You can look up the application directly without listing all the applications. Use the _location_ header that is included in the response when the application is created.
      <br/>Note: The following example uses a query to retrieve only a small number of the application's properties.

      ---
      ```
      # The API:
      /api/application/applications/{uuid}

      # The query:
      fields=name,template.name,generation,state

      # The call:
      curl -X GET "https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2?fields=name,template.name,generation,state" -H "accept: application/json"

      # The response:
      {
        "uuid": "dbc10d87-df5a-11e7-b5d2-005056b47eb2",
        "name": "my_ora_app",
        "template": { "name": "oracle_on_nfs" },
        "generation": 2,
        "state": "online"
      }
      ```
      ---

      ### 5) Discover how to access the application

      The components API provides information on how to access the storage that is provisioned for the application.
      <br/>For brevity, only the names of the components are requested. See the API documentation for more information on the other available fields.

      ---
      ```
      # The API:
      api/application/applications/{application.uuid}/components

      # The query:
      fields=name

      # The call:
      curl -X GET "https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2/components?fields=name" -H "accept: application/json"

      # The response:
      {
        "records": [
          { "uuid": "e06fb407-df5a-11e7-b5d2-005056b47eb2", "name": "db" },
          { "uuid": "e0709732-df5a-11e7-b5d2-005056b47eb2", "name": "ora_home" },
          { "uuid": "e07158eb-df5a-11e7-b5d2-005056b47eb2", "name": "redo_log" }
        ],
        "num_records": 3
      }
      ```
      ---

      ### 6) Update the application

      To update the storage service, the same template that is used for creating the application is reused, but with only the storage_service properties set. In the generic SAN and NAS templates, the name of each component must also be specified.
      <br/>In this example, the cluster only supports the _value_ storage service, so modifications of the application to a faster storage service fail. Note how the error message indicates the parameter that caused the problem.
      <br/>Application modification, like application creation, is an asynchronous operation. If a valid command is passed, the API returns information about the job instead of an error.

      ---
      ```
      # The API:
      /api/application/applications/{uuid}

      # The body:
      {
        "oracle_on_nfs": { "db": { "storage_service": { "name": "extreme" } } }
      }

      # The call:
      curl -X PATCH "https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2" -H "accept: application/hal+json" -H "content-type: application/json" -d '{ "oracle_on_nfs": { "db": { "storage_service": { "name": "extreme" } } } }'

      # The response:
      {
        "error": {
          "message": "Invalid value for parameter \"oracle_on_nfs.db.storage-service.name\": extreme. Supported values are: value.",
          "code": "65995152"
        }
      }
      ```
      ---

      ### 7) Manage Snapshot copies

      For applications created with the _local_ _protection_type_ set to _hourly_, Snapshot copies are automatically taken every hour. These Snapshot copies can be retrieved or restored using the Snapshot copy APIs. Snapshot copies can also be taken on demand using these APIs. It is important to note that the _consistency_type_ flag of the Snapshot copy is for record-keeping only: it is the responsibility of the administrator to ensure that the application is in a consistent state prior to flagging a Snapshot copy as _application_ consistent.
      <br/>Take a Snapshot copy manually:

      ---
      ```
      # The API:
      /api/application/applications/{uuid}/snapshots

      # The body:
      {
          "name": "little_bobby_tables",
          "consistency_type": "crash"
      }

      # The call:
      curl -X POST "https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2/snapshots" -H "accept: application/hal+json" -H "content-type: application/json" -d '{ "name": "little_bobby_tables", "consistency_type": "crash"}'

      # The response:
      {}

      # The response header:
      date: Tue, 12 Dec 2017 17:40:10 GMT
      server: libzapid-httpd
      content-type: application/hal+json
      location: /api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2/snapshots/dbc10d87-df5a-11e7-b5d2-005056b47eb2_13_little_bobby_tables
      cache-control: no-cache,no-store,must-revalidate
      connection: Keep-Alive
      keep-alive: timeout=5, max=100
      content-length: 3
      ```
      ---

      In the above example, the response body is empty, and the response header includes the _location_ of the newly created Snapshot copy. By default, all POST calls return an empty body unless a job is used to process the creation asynchronously. This behavior can be changed with the query flag _return_records_.
      <br/>Restoring a Snapshot copy uses an action API. Action paths can also be performed asynchronously as jobs, as with creating or modifying an application. The response header does not include a _location_, because this action is not creating a resource.

      ---
      ```
      # The API:
      /api/application/applications/{application.uuid}/snapshots/{snapshot.uuid}/restore

      # The call:
      curl -X POST "https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2/snapshots/dbc10d87-df5a-11e7-b5d2-005056b47eb2_13_little_bobby_tables/restore" -H "accept: application/hal+json"

      # The response:
      {
        "job": {
          "uuid": "00e81690-df64-11e7-b5d2-005056b47eb2",
          "id": 100,
          "_links": {
            "self": {
              "href": "/api/cluster/jobs/00e81690-df64-11e7-b5d2-005056b47eb2"
            }
          }
        }
      }

      # The response header:
      date: Tue, 12 Dec 2017 17:43:46 GMT
      cache-control: no-cache,no-store,must-revalidate
      server: libzapid-httpd
      connection: Keep-Alive
      keep-alive: timeout=5, max=100
      content-length: 204
      content-type: application/hal+json
      ```
      ---

      ## Smart containers
      Smart containers are traditional ONTAP storage objects such as FlexVol or FlexGroup created using the application REST API.
      * NAS - FlexVolume, FlexGroup, and FlexCache objects
      * SAN - LUNs
      * NVME - Namespaces
      ---
      The benefits of creating a Smart Container are as follows:
      * ONTAP determines the best placement for the storage object based on available performance and space capacity.
      * Access controls can be optionally set.
      * Snapshot copy schedules can be optionally set.
      * A single atomic job that does all the above.
      ***
      Smart containers are similar to generic enterprise applications (NAS, SAN, NVME), but with certain restrictions. Smart containers are restricted to 1 application-component. Any post-provisioning data management operations on smart containers must be performed via PATCH operations corresponding to the object created. However, the POST, GET and DELETE operations that exist for applications will also operate for smart containers.

      <br/>To create a Smart Container the "smart_container:true" parameter must be provided.<br/>
      ---
      Prior to creating a smart container, the following prerequisites must be met for the protocols associated with the template:
      * Licences must be installed.
        * [`POST /cluster/licensing/licenses`](#cluster/license_create)
      * Aggregates must exist with enough available space to satisfy the requested size.
        * [`POST /storage/aggregates`](#storage/aggregate_create)
      * An SVM must exist with protocol services enabled.
        * [`POST /svm/svms`](#svm/svm_create)
      * LIFs must exist. For SAN objects, only High Availability groups where each node has at least one LIF to be considered for placement of storage objects.
        * [`POST /network/ip/interfaces`](#networking/network_ip_interfaces_create)
        * [`POST /network/fc/interfaces`](#networking/fc_interface_create)
      ---
      The following are not required prior to creating a smart container:
      * Network routes must be created to access Ethernet-based LIFs.
        * [`POST /network/ip/routes`](#networking/network_ip_routes_create)
      * To mount volumes by this operation successfully, all ONTAP requirements related to mounting must be met.
      ***
      ### Example
      The following examples outline the APIs necessary to create a smart container. Two types of smart container creation are supported:
      * A smart container with new ONTAP storage objects as specified in the JSON body.
      * An existing ONTAP volume can be converted into a smart container (supported only on generic SAN and NVME templates).
      This is an addendum to the example provided on how to create an application.
      ```
      # The API:
      /api/application/applications

      # The query:
      No query is needed for this command. Optionally, you can specify the return_timeout or set the return_records flag to alter the behavior of the command.

      # The body:
      Creates a smart container with new ONTAP storage objects:
      {
        "name": "my_container",
        "svm": {
            "name":"vs1"
        },
        "template": {
            "name":"nas"
        },
        "smart_container": "true"
        "nas": {
            "application_components": [
                {
                    "share_count": "1",
                    "name": "myVolume",
                    "storage_service": {
                        "name": "value"
                    },
                    "total_size": "100mb"
                }
            ]
        }
      }
      Converting an existing volume into a smart container:
      {
        "name": "my_container",
        "svm": {
            "name":"vs1"
        },
        "template": {
            "name":"san"
        },
        "smart_container": "true"
        "san": {
            "application_components": [
                {
                    "name": "existingVolume" #name of an existing volume
                }
            ]
        }
      }

      # The call:
      Creates a smart container with new ONTAP storage objects:
      curl -X POST "https://<mgmt-ip>/api/application/applications" -H "accept: application/hal+json" -H "Content-Type: application/json" -d '{"name": "my_container", "svm": {"name": "vs1"} , "smart_container": true , "template": {"name": "nas"} , "nas": {"application_components": [{"share_count": "1", "name": "myVolume", "storage_service": {"name": "value"} , "total_size": "100mb"} ] } }'

      Converting an existing volume into a smart container:
      curl -X POST "https://<mgmt-ip>/api/application/applications" -H "accept: application/hal+json" -H "Content-Type: application/json" -d '{"name": "my_container", "svm": {"name": "vs1"} , "smart_container": true , "template": {"name": "san"} , "san": {"application_components": [{"name": "existingVolume"} ] } }'
      # The response:
       {
           "job": {
               "uuid": "5440db05-77f0-11e9-a5a0-005056bba32f",
               "_links": {
                   "self": {
                       "href": "/api/cluster/jobs/5440db05-77f0-11e9-a5a0-005056bba32f"
                   }
               }
           }
       }

      # The response header:
      date: Tue, 23 May 2019 16:38:18 GMT
      server: libzapid-httpd
      content-type: application/hal+json
      location: /api/application/applications/5440db05-77f0-11e9-a5a0-005056bba32f
      cache-control: no-cache,no-store,must-revalidate
      connection: Keep-Alive
      keep-alive: timeout=5, max=100
      content-length: 203
      ```
      ---

      ## Smart Container Properties
      These sections are only allowed for smart containers and will return an error when provided on traditional applications. The following is an example of the error returned:
      ```
      {
      "error": {
          "message": "Field \"<field>\" is only supported on smart containers.",
          "code": "65996161"
          }
      }
      ```
      ---

      ## Updating the smart container
      A smart container can be updated to add more LUNS and/or namespaces, with the same template used to create a smart container being reused, and with the following fields set:
      * lun_count/namespace_count - represents the total number of LUNS/namespaces in the smart container.
      * os_type - represents the OS type of the new LUNS/namespaces.
      * total_size - represents the total size of the new LUNS/namespaces to be added.
      * igroup_name/subsystem - represents the igroup/subsystem mapping for the new LUNS/namespaces.

      Updates are allowed only on generic SAN and NVME templates.

      ---
      ```
      # The API:
      /api/application/applications/{uuid}

      # The body:
      {
        "san": {
            "application_components": [
                {
                    "name": "myVolume",
                    "lun_count": 4
                    "total_size": "1gb"
                    "os-type": "linux",
                    "igroup_name": "igroup1"
                }
            ]
        }
      }

      # The call:
      curl -X PATCH "https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2" -H "accept: application/hal+json" -H "content-type: application/json" -d '{ "san": { "application_components": [{ "name": "myVolume", "total_size": "1GB", "lun_count": 4, "os_type": "linux", "igroup_name": "igroup1"}]}}'
      ```
      ## Application API limitations
      ## Application API limitations

      ### Template versus generic

      Applications can be represented in either template or generic terms. All applications can be represented in generic terms as a list of components. Each component generally maps to a field in the template. For example, Microsoft SQL Server applications have a component named _sqldata_ that corresponds to the _db_ parameter in the sql_on_san template. These mappings are usually straightforward and allow the templates to present application terminology, while the generic view uses the traditional naming schemes for ONTAP storage elements.
      <br/>The current release supports the creation and modification of applications in template terms, but retrieval is not supported. The mapping from template to generic terms is left to your own discretion.za

      ### ONTAP feature support

      Application APIs are interfaces layered on top of traditional ONTAP storage. While the intent is to provide a full management suite through application APIs, some features of the underlying ONTAP objects are not directly supported through application APIs. Applications are provisioned using ONTAP best practices, so the need for additional modifications of the underlying objects should be minimal. If such modifications are necessary, the traditional ONTAP APIs can be used. The _/api/application/{application.uuid}/components_ API provides a _backing_storage_ field that can be used to locate the storage objects associated with an application. This API also provides details of the NFS, CIFS, or SAN protocol access objects associated with the application.
      <br/>The application APIs use the extra information known about the application to coordinate multiple ONTAP objects in unison. When using non-application APIs, certain settings might interfere with the ONTAP object coordination and cause the application APIs to behave unexpectedly. To continue to supply the full ONTAP feature set, these modifications on the underlying objects are allowed, but there is no guarantee that these modifications will not adversely affect the application experience. You should use this feature with caution.

  - name: support
    description: Manages backups, autosupports, and event handling
    x-ntap-long-description: |
      ## Overview

      You can use ONTAP support APIs to manage configuration backups, autosupport settings, and event handling.

      ### Configuration backups

      Configuration backups are copies of node and cluster settings saved to an external server.

      Single-node clusters must have configuration backups as protection against corruption of the configuration database. Multi-node clusters back up the configuration automatically between the nodes in the cluster.

  - name: security
    description: Manage the security settings for the cluster and SVMs
    x-ntap-long-description: |
      ## Overview

      You can use ONTAP security APIs to manage security settings for the cluster and SVMs.

      ### SAML
      Configure the SAML 2.0 SP (Service Provider) protocol inside ONTAP. Doing so redirects the authentication task to a third-party Identity Provider (IDP) that can utilize any number of approaches for multi-factor authentication. After SAML authentication is enabled, all interactive web access (System Manager, SPI) is authenticated via SAML and a third-party IDP.

  - name: storage
    description: Manages physical and logical storage
    x-ntap-long-description: |
      ## Overview

      The ONTAP storage APIs can be used to manage physical and logical storage. This includes management of aggregates, volumes, LUNs, qtrees, snapshots, quotas, and storage effeciency.
      <br/>

  - name: snapmirror
    description: Manages asynchronous extended data protection (XDP) relationships for FlexVols, FlexGroups, or SVMs
    x-ntap-long-description: |
      ## Overview
      SnapMirror technology enables customers to copy and backup their production data. The secondary or destination volume in such a backup relationship can reside anywhere, locally or remotely, and can be used to restore access to the protected data. You can restore access to protected data by drawing upon a vault of backups or, in the event that a primary is unusable, by using a disaster recovery copy that can be activated for clients and applications. SnapMirror periodically updates a replica to create new backups and/or to keep a replica up-to-date with changes that have been written to the primary. The SnapMirror subsystems are designed to keep many pairs of source (primary) and destination (secondary) copies up-to-date in an efficient and scalable manner. <br/>
      The SnapMirror APIs can be used to create and manage SnapMirror relationships of type "async", and "sync". These APIs can also be used to manage restore-relationships. These APIs allow you to manage the following endpoints:

      * SnapMirror policies - When applied to a SnapMirror relationship, the SnapMirror policy controls the behavior of the relationship and specifies the configuration attributes for that relationship.
      * SnapMirror relationships - You can create and manage SnapMirror relationships, and you can change the state of the SnapMirror relationship using a PATCH request.
      * SnapMirror transfers - You can manage data transfers on the specified SnapMirror relationship.

  - name: ndmp
    description: Manages NDMP services
    x-ntap-long-description: |
      NDMP (Network Data Management Protocol) provides an open standard for network-based backup of network-attached storage (NAS). NDMP minimizes the coding required for different applications by providing standard commands for backing up and restoring file servers. NDMP increases the speed and efficiency of NAS data protection, as data can bypass backup servers and be written directly to tape storage. Starting from ONTAP 8.2, the software supports SVM aware NDMP backups. This helps in optimizing NDMP backup performance by choosing efficient data transfer paths and is fully compatible with integrated non-disruptive operations and volume mobility capabilities of ONTAP software. In order to support this feature, a CAB extension must be implemented by backup vendors.

      These APIs allow you to manage the following endpoints:

      * ndmp
      * ndmp nodes
      * ndmp svms
      * ndmp sessions

      ## APIs

      ### NDMP

      These APIs are used to manage NDMP mode, SVM-scope or node-scope.

      ### NDMP nodes

      These APIs are used to manage node configurations.

      ### NDMP SVMs

      These APIs are used to manage NDMP configurations of SVMs.

      ### NDMP sessions

      These APIs are used to manage diagnostic information on NDMP sessions belonging to a specific SVM in the case of SVM-scope or to a specific node in the case of node-scope.

  - name: snaplock
    description: SnapLock is a high-performance compliance solution that uses WORM storage to retain files in an unmodified form.
    x-ntap-long-description: |
      SnapLock is an alternative to the traditional optical "write once, read many" (WORM) data. SnapLock is used for the storage of read-only WORM data. SnapLock is a license-based, disk-based, open-protocol feature that works with application software to administer non-rewritable storage of data. The primary objective of this feature is to provide storage-enforced WORM and retention functionality. SnapLock can be deployed for protecting data in strict regulatory environments in such a way that even the storage administrator is considered an untrusted party. SnapLock provides special purpose volumes in which files can be stored and committed to a non-erasable, non-rewritable state either forever or for a designated retention period. SnapLock allows this retention to be performed at the granularity of individual files.
      These APIs allow you to manage the following endpoints:

      * SnapLock log
      * SnapLock compliance-clock
      * SnapLock event-retention
      * SnapLock file retention
      * SnapLock privileged-delete
      * SnapLock file fingerprint
      * SnapLock legal-hold

      ## APIs

      ###  SnapLock log

      These APIs are used to create and initialize the SnapLock log configuration for an SVM, modify attributes associated with the SnapLock log configuration,and delete the auditlog configuration.

      ###  SnapLock compliance-clock

      This API  manages the ComplianceClock of the system. ComplianceClock determines the expiry time of the SnapLock objects in the system. ComplianceClock can be initialized only once by the user and once it is set, it cannot be changed or altered by the user.

      ### SnapLock event-retention

      This API is used to create Event Based Retention (EBR) policies for an SVM. A policy consists of a policy-name and a retention-period. Only a user with security login role vsadmin-snaplock is allowed to perform this operation.

      ### SnapLock file retention

      This API is used to set the retention time of a file. Retention time expects the date in ISO 8601 format or "infinite".

      ### SnapLock privileged-delete

      This API is used to perform a privileged-delete operation on unexpired WORM files on a SnapLock Enterprise volume. The only built-in role that has access to the command is "vsadmin-snaplock".

      ### SnapLock file fingerprint

      This API is used to start the fingerprint computation on a file.

      ### SnapLock legal-hold

      This API is used to retain Compliance-mode WORM files for the duration of a litigation. A file under a Legal-Hold behaves like a WORM file with an indefinite retention period. Only a user with security login role vsadmin-snaplock is allowed to perform the operation.


  - name: NAS
    description: Manages the NFS and export settings for clusters and SVMs
    x-ntap-long-description: |
      ## Overview
      These APIs allow you to complete various tasks, including:

      * Creating an NFS server for an SVM
      * Managing an NFS configuration of an SVM
      * Viewing and updating the NFS configuration of an SVM
      * Configuring export policies and rules for an SVM
      * Managing export policies and rules for an SVM

      ## APIs

      ### NFS
      The NFS APIs enable you to create and configure NFS settings for an SVM. You can delete or update NFS configurations, and you can also disable or enable different NFS features as needed.

      The export APIs allow you to create and manage export policies for an SVM that enable an administrator to restrict access to volumes for clients that match specific IP addresses and specific authentication types. Export APIs are also used to create export rules for an export policy. The APIs allow each rule to specify the number of mask bits in the client IP address that must be matched for that rule to apply to a particular client request. The APIs also allow each export rule to specify the authentication types that are required for both read-only and read-write operations.

      ### Kerberos
      Kerberos is a protocol designed to provide strong authentication for users and hosts within a client/server environment. The basis of the protocol is a shared, secret-key cryptology system. (Kerberos uses shared-key encryption to ensure the confidentiality of the data. It also uses hashing techniques to ensure the integrity of the data (so that no one can modify the data unless allowed to do so). With the NetApp multiprotocol storage platform, through which clients based on UNIX or Windows can access data using CIFS or NFS, it is crucial to provide the ability to use standard network services for authentication and for identity storage.<br/>

      To configure an ONTAP system to use Kerberos for NFS, Kerberos must be enabled on a data LIF in the SVM that owns the NFS server. A Kerberos realm needs to be created before enabling Kerberos on a data LIF. (The Kerberos realm is needed so that the cluster knows how to format Kerberos ticket requests.) The Kerberos APIs allow you to define, create, modify, and delete realms for the SVM. The APIs also allow you to enable/disable Kerberos on a data LIF and update the Kerberos interface configuration for a particular data LIF in the SVM.

paths:
  /storage/volumes:
    x-ntap-long-description:
      tags: [ storage ]
      description: |
        ## Overview
        FlexVol volumes are logical containers used by ONTAP to serve data to clients.  They contain file systems in a NAS environment and LUNs in a SAN environment.<br/>
        A FlexGroup volume is a scale-out NAS container that provides high performance along with automatic load distribution and scalability. A FlexGroup volume contains several constituents that automatically and transparently share the traffic.</br>
        FlexClone volumes are writable, point-in-time copies of a FlexVol volume. At this time, FlexClones of FlexGroups are not supported.<br/>
        Volumes with SnapLock type Compliance or Enterprise, are referred to as SnapLock volumes. Volumes with SnapLock type cannot be of FlexGroup style. Once a SnapLock aggregate is created, by default, volumes created inside the aggregate inherit the "snaplock" property from the aggregate. It is possible to create a SnapLock volume by specifying SnapLock parameters. SnapLock parameters are only available at the "advanced" privilege level.<br/>
        ONTAP storage APIs allow you to create, modify, and monitor volumes and aggregates.<br/>
  
        ## Storage efficiency
        Storage efficiency is used to remove duplicate blocks in the data and to compress the data. Efficiency has deduplication, compression, cross volume deduplication, and compaction options. On All Flash systems, all efficiencies are enabled by default on volume creation. Options such as "background/inline/both" are treated as both, which means both background and inline are enabled for any efficiency option. The option "none"  disables both background and inline efficiency.<br/>
        To enable any efficiency option on all-flash or FAS systems, background deduplication is always enabled.<br/>
  
        ## Quotas
        Quotas provide a way to restrict or track the files and space usage by a user, group, or qtree. Quotas are enabled for a specific FlexVol or a FlexGroup volume.<br/>
        The following APIs can be used to enable or disable and obtain quota state for a FlexVol or a FlexGroup volume:
  
        &ndash; PATCH  /api/storage/volumes/{uuid} -d '{"quota.enabled":"true"}'
        &ndash; PATCH  /api/storage/volumes/{uuid} -d '{"quota.enabled":"false"}'
        &ndash; GET    /api/storage/volumes/{uuid}/?fields=quota.state
  
        ## File System Analytics
        File system analytics provide a quick method for obtaining information summarizing properties of all files within any directory tree of a volume. For more information on file system analytics, see [`DOC /storage/volumes{volume.uuid}/files/{path}`](#docs-storage-storage_volumes_{volume.uuid}_files_{path}). Analytics can be enabled or disabled on individual volumes.<br/>
        The following APIs can be used to enable or disable and obtain analytics state for a FlexVol volume or a FlexGroup volume:
  
        &ndash; PATCH  /api/storage/volumes/{uuid} -d '{"analytics.state":"on"}'
        &ndash; PATCH  /api/storage/volumes/{uuid} -d '{"analytics.state":"off"}'
        &ndash; GET    /api/storage/volumes/{uuid}/?fields=analytics
  
        ## QoS
        QoS policy and settings enforce Service Level Objectives (SLO) on a volume. SLO can be set by specifying qos.max_throughput_iops and/or qos.max_throughput_mbps or qos.min_throughput_iops. Specifying min_throughput_iops is only supported on volumes hosted on a node that is flash optimized. A pre-created QoS policy can also be used by specifying qos.name or qos.uuid property. <br/>
  
        ## Performance monitoring
        Performance of a volume can be monitored by the `metric.*` and `statistics.*` fields. These show the performance of the volume in terms of IOPS, latency and throughput. The `metric.*` fields denote an average whereas `statistics.*` fields denote a real-time monotonically increasing value aggregated across all nodes. <br/>
  
        ## Volume APIs
        The following APIs are used to perform operations related with FlexVol volumes and FlexGroup volumes:
  
        &ndash; POST      /api/storage/volumes
        &ndash; GET       /api/storage/volumes
        &ndash; GET       /api/storage/volumes/{uuid}
        &ndash; PATCH     /api/storage/volumes/{uuid}
        &ndash; DELETE    /api/storage/volumes/{uuid}
  
        ## Examples
        ### Creating a volume
        The POST request is used to create a new volume and to specify its properties.
        ```
        # The API:
        /api/storage/volumes
  
        # The call:
        curl -X POST  "https://<mgmt-ip>/api/storage/volumes" -H "accept: application/hal+json" -d '{"name": "vol1", "aggregates":[{"name":"aggr1"}], "svm":{"name" : "vs1"}}'
  
        # The response:
        {
          "job": {
            "uuid": "b89bc5dd-94a3-11e8-a7a3-0050568edf84",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/b89bc5dd-94a3-11e8-a7a3-0050568edf84"
              }
            }
          }
        }
        ```
  
        ### Creating a SnapLock volume and specifying its properties using POST
        ```
        # The API:
        /api/storage/volumes
  
        # The call:
        curl -X POST  "https://<mgmt-ip>/api/storage/volumes" -H "accept: application/hal+json" -d '{"name": "vol1",  "aggregates":[{"name": "aggr1"}],  "svm":{"name" : "vs1"}, "snaplock":{"retention":{"default": "P20Y"}}}'
  
        # The response:
        {
          "job": {
            "uuid": "e45b123b-c228-11e8-aa20-0050568e36bb",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/e45b123b-c228-11e8-aa20-0050568e36bb"
              }
            }
          }
        }
        ```
  
        ### Creating a FlexGroup volume and specifying its properties using POST
        ```
        # The API:
        /api/storage/volumes
  
        # The call:
        curl -X POST  "https://<mgmt-ip>/api/storage/volumes" -H "accept: application/hal+json" -d '{"name" : "vol1", "state" : "online", "type" : "RW", "aggregates" : [{"name" : "aggr1"}, {"name" : "aggr2"}, {"name":"aggr3"}], "constituents_per_aggregate" : "1", "svm" : {"name" : "vs1"}, "size" : "240MB", "encryption" : {"enabled" : "False"}, "efficiency" : {"compression" : "both"}, "autosize" : {"maximum" : "500MB", "minimum" : "240MB"}}'
  
        # The response:
        {
          "job": {
            "uuid": "3cfa38bd-3a78-11e9-ae39-0050568ed7dd",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/3cfa38bd-3a78-11e9-ae39-0050568ed7dd"
              }
            }
          }
        }
        ```
  
        ### Creating a FlexClone and specifying its properties using POST
        ```
        # The API:
        /api/storage/volumes
  
        # The call:
        curl -X POST  "https://<mgmt-ip>/api/storage/volumes" -H "accept: application/hal+json" -d '{"name":"vol1_clone", "clone": {"parent_volume": {"name": "vol1"}, "is_flexclone": "true"},"svm":{"name": "vs0"}}'
  
        # The response:
        HTTP/1.1 202 Accepted
        Date: Tue, 26 Feb 2019 09:06:22 GMT
        Server: libzapid-httpd
        X-Content-Type-Options: nosniff
        Cache-Control: no-cache,no-store,must-revalidate
        Location: /api/storage/volumes/?name=vol1_clone
        Content-Length: 189
        Content-Type: application/hal+json
  
        {
          "job": {
            "uuid": "c9ee0040-39a5-11e9-9b24-00a098439a83",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/c9ee0040-39a5-11e9-9b24-00a098439a83"
              }
            }
          }
        }
        ```
  
        ## Volumes reported in the GET REST API
        ### The following types of volumes are reported:
        &ndash;  RW, DP and LS volume
        &ndash;  FlexGroup volume
        &ndash;  FlexCache volume
        &ndash;  FlexClone volume
        <br/>
  
        ### The following types of volumes are not reported:
        &ndash;  DEL volume
        &ndash;  TEMP volume
        &ndash;  Node Root volume
        &ndash;  System Vserver volume
        &ndash;  FlexGroup constituent
        &ndash;  FlexCache constituent
  
        ## Examples
        ### Retrieving the list of volumes
        ```
  
        # The API:
        /api/storage/volumes
  
        # The call:
        curl -X GET "https://<mgmt-ip>/api/storage/volumes" -H "accept: application/hal+json"
  
        # The response:
        {
          "records": [
            {
              "uuid": "2d1167cc-c3f2-495a-a23f-8f50b071b9b8",
              "name": "vsdata_root",
              "_links": {
                "self": {
                  "href": "/api/storage/volumes/2d1167cc-c3f2-495a-a23f-8f50b071b9b8"
                }
              }
            },
            {
              "uuid": "3969be7e-78b4-4b4c-82a4-fa86331f03df",
              "name": "vsfg_root",
              "_links": {
                "self": {
                  "href": "/api/storage/volumes/3969be7e-78b4-4b4c-82a4-fa86331f03df"
                }
              }
            },
            {
              "uuid": "59c03ac5-e708-4ce8-a676-278dc249fda2",
              "name": "svm_root",
              "_links": {
                "self": {
                  "href": "/api/storage/volumes/59c03ac5-e708-4ce8-a676-278dc249fda2"
                }
              }
            },
            {
              "uuid": "6802635b-8036-11e8-aae5-0050569503ac",
              "name": "fgvol",
              "_links": {
                "self": {
                  "href": "/api/storage/volumes/6802635b-8036-11e8-aae5-0050569503ac"
                }
              }
            },
            {
              "uuid": "d0c3359c-5448-4a9b-a077-e3295a7e9057",
              "name": "datavol",
              "_links": {
                "self": {
                  "href": "/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057"
                }
              }
            }
          ],
          "num_records": 5,
          "_links": {
            "self": {
              "href": "/api/storage/volumes"
            }
          }
        }
        ```
  
        ### Retrieving the attributes of a volume
        The GET request is used to retrieve the attributes of a volume.
        ```
        # The API:
        /api/storage/volumes/{uuid}
  
        # The call:
        curl -X GET "https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057" -H "accept: application/hal+json"
  
        # The response:
        {
          "uuid": "d0c3359c-5448-4a9b-a077-e3295a7e9057",
          "comment": "This is a data volume",
          "create_time": "2018-07-05T14:56:44+05:30",
          "language": "en_us",
          "name": "datavol",
          "size": 20971520,
          "state": "online",
          "style": "flexvol",
          "tiering_policy": "auto",
          "type": "rw",
          "aggregates": [
            {
              "name": "data",
              "uuid": "aa742322-36bc-4d98-bbc4-0a827534c035",
              "_links": {
                "self": {
                  "href": "/api/cluster/aggregates/data"
                }
              }
            }
          ],
          "encryption": {
            "enabled": false,
            "state": "none",
            "key_id": "",
            "type" : "none"
          },
          "error_state": {
            "has_bad_blocks": false,
            "is_inconsistent": false
          },
          "files": {
            "maximum": 566,
            "used": 96
          },
          "nas": {
            "gid": 2468,
            "security_style": "unix",
            "uid": 1357,
            "unix_permissions": 4755,
            "export_policy": {
              "name": "default",
              "id": 8589934593
            }
          },
          "metric": {
            "timestamp": "2019-04-09T05:50:15Z",
            "status": "ok",
            "duration": "PT15S",
            "latency": {
              "other": 0,
              "total": 0,
              "read": 0,
              "write": 0
            },
            "iops": {
              "read": 0,
              "write": 0,
              "other": 0,
              "total": 0
            },
            "throughput": {
              "read": 0,
              "write": 0,
              "other": 0,
              "total": 0
            },
            "cloud": {
              "timestamp": "2019-04-09T05:50:15Z",
              "status": "ok",
              "duration": "PT15S",
              "iops" : {
                "read": 0,
                "write": 0,
                "other": 0,
                "total": 0
              },
              "latency": {
                "read": 0,
                "write": 0,
                "other": 0,
                "total": 0
              }
            },
            "flexcache": {
              "timestamp": "2019-04-09T05:50:15Z",
              "status": "ok",
              "duration": "PT1D",
              "cache_miss_percent": 0
            }
          },
          "statistics": {
            "timestamp": "2019-04-09T05:50:42Z",
            "status": "ok",
            "latency_raw": {
              "other": 38298,
              "total": 38298,
              "read": 0,
              "write": 0
            },
            "iops_raw": {
              "read": 0,
              "write": 0,
              "other": 3,
              "total": 3
            },
            "throughput_raw": {
              "read": 0,
              "write": 0,
              "other": 0,
              "total": 0
            },
            "cloud": {
              "timestamp": "2019-04-09T05:50:42Z",
              "status": "ok",
              "iops_raw" : {
                "read": 0,
                "write": 0,
                "other": 0,
                "total": 0
              },
              "latency_raw": {
                "read": 0,
                "write": 0,
                "other": 0,
                "total": 0
              }
            },
            "flexcache_raw": {
              "timestamp": "2019-04-09T05:50:15Z",
              "status": "ok",
              "cache_miss_blocks": 0,
              "client_requested_blocks": 0
            }
          },
          "qos": {
            "policy": {
            "min_throughput_iops": 0,
            "max_throughput_iops": 1000,
            "max_throughput_mbps": 0,
            "uuid": "228454af-5a8b-11e9-bd5b-005056ac6f1f",
            "name": "pg1"
            }
          },
          "snaplock": {
            "append_mode_enabled": false,
            "autocommit_period": "none",
            "compliance_clock_time": "2019-05-24T10:59:00+05:30",
            "expiry_time": "2038-01-19T08:44:28+05:30",
            "is_audit_log": false,
            "litigation_count": 0,
            "privileged_delete": "disabled",
            "type": "enterprise",
            "retention": {
              "default": "P0Y",
              "minimum": "P0Y",
              "maximum": "P30Y"
            }
          },
          "snapshot_policy": {
            "name": "default"
          },
          "svm": {
            "name": "vsdata",
            "uuid": "d61b69f5-7458-11e8-ad3f-0050569503ac"
          },
          "_links": {
            "self": {
              "href": "/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057"
            }
          }
        }
        ```
  
        ### Retrieving the quota state of a FlexVol or a FlexGroup volume
        ```
        # The API:
        /api/storage/volumes/{uuid}
  
        # The call:
        curl -X GET "https://<mgmt-ip>/api/storage/volumes/cb20da45-4f6b-11e9-9a71-005056a7f717/?fields=quota.state" -H "accept: application/hal+json"
  
        # The response:
        {
          "uuid": "cb20da45-4f6b-11e9-9a71-005056a7f717",
          "name": "fv",
          "quota": {
            "state": "on"
          },
          "_links": {
            "self": {
              "href": "/api/storage/volumes/cb20da45-4f6b-11e9-9a71-005056a7f717/"
            }
          }
        }
        ```
        ## Updating the attributes of a volume
  
        ## Examples
        ### Updating the attributes of a volume
        The PATCH request is used to update the attributes of a volume.
        ```
        # The API:
        /api/storage/volumes/{uuid}
  
        # The call:
        curl -X PATCH  "https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057" -d '{ "size": 26214400, "nas": {"security_style": "mixed"}, "comment": "This is a data volume" }' -H "accept: application/hal+json"
  
        # The response:
        HTTP/1.1 202 Accepted
        Date: Tue, 31 Jul 2018 09:36:43 GMT
        Server: libzapid-httpd
        Cache-Control: no-cache,no-store,must-revalidate
        Content-Length: 189
        Content-Type: application/hal+json
  
        {
          "job": {
            "uuid": "3c5be5a6-94a5-11e8-8ca3-00505695c11b",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/3c5be5a6-94a5-11e8-8ca3-00505695c11b"
              }
            }
          }
        }
        ```
  
        ### Updating the attributes of a FlexClone using PATCH
        ```
        # The API:
        /api/storage/volumes/{uuid}
  
        # The call:
        curl -X PATCH  "https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057" -d '{"clone":{"split_initiated":"true"}}' -H "accept: application/hal+json"
  
        # The response:
        HTTP/1.1 202 Accepted
        Date: Mon, 25 Feb 2019 10:10:19 GMT
        Server: libzapid-httpd
        X-Content-Type-Options: nosniff
        Cache-Control: no-cache,no-store,must-revalidate
        Content-Length: 189
        Content-Type: application/hal+json
  
        {
          "job": {
            "uuid": "8e01747f-38e5-11e9-8a3a-00a09843994b",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/8e01747f-38e5-11e9-8a3a-00a09843994b"
              }
            }
          }
        }
        ```
  
        ### Enabling quotas for a FlexVol or a FlexGroup volume using PATCH
        ```
        # The API:
        /api/storage/volumes/{uuid}
  
        # The call:
        curl -X PATCH  "https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057" -d '{"quota":{"enabled":"true"}}' -H "accept: application/hal+json"
  
        # The response:
        HTTP/1.1 202 Accepted
        Date: Mon, 25 Feb 2019 10:10:19 GMT
        Server: libzapid-httpd
        X-Content-Type-Options: nosniff
        Cache-Control: no-cache,no-store,must-revalidate
        Content-Length: 189
        Content-Type: application/hal+json
  
        {
          "job": {
            "uuid": "d2fe7299-57d0-11e9-a2dc-005056a7f717",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/d2fe7299-57d0-11e9-a2dc-005056a7f717"
              }
            }
          }
        }
        ```
  
        ### Disabling quotas for a FlexVol or a FlexGroup volume using PATCH
        ```
        # The API:
        /api/storage/volumes/{uuid}
  
        # The call:
        curl -X PATCH  "https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057" -d '{"quota":{"enabled":"false"}}' -H "accept: application/hal+json"
  
        # The response:
        HTTP/1.1 202 Accepted
        Date: Mon, 25 Feb 2019 10:10:19 GMT
        Server: libzapid-httpd
        X-Content-Type-Options: nosniff
        Cache-Control: no-cache,no-store,must-revalidate
        Content-Length: 189
        Content-Type: application/hal+json
  
        {
          "job": {
            "uuid": "0c8f6bea-57d1-11e9-a2dc-005056a7f717",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/0c8f6bea-57d1-11e9-a2dc-005056a7f717"
              }
            }
          }
        }
        ```
  
        ## Add tiering object tags for a FlexVol using PATCH
        ```
        # The API:
        /api/storage/volumes/{uuid}
  
        # The call:
        curl -X PATCH  "https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057" -d '{"tiering.object_tags": [ "key1=val1", "key2=val2" ]}' -H "accept: application/hal+json"
  
        # The response:
        HTTP/1.1 202 Accepted
        Date: Tue, 11 Feb 2020 19:29:25 GMT
        Server: libzapid-httpd
        X-Content-Type-Options: nosniff
        Cache-Control: no-cache,no-store,must-revalidate
        Content-Length: 189
        Content-Type: application/hal+json
  
        {
          "job": {
            "uuid": "d05012de-4d04-11ea-836b-005056bb6f9d",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/d05012de-4d04-11ea-836b-005056bb6f9d"
              }
            }
          }
        }
        ```
  
        ### Remove tiering object tags for a FlexVol using PATCH
        ```
        # The API:
        /api/storage/volumes/{uuid}
  
        # The call:
        curl -X PATCH  "https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057" -d '{"tiering.object_tags": []}' -H "accept: application/hal+json"
  
        # The response:
        HTTP/1.1 202 Accepted
        Date: Fri, 24 Jan 2020 22:28:04 GMT
        Server: libzapid-httpd
        X-Content-Type-Options: nosniff
        Cache-Control: no-cache,no-store,must-revalidate
        Content-Length: 189
        Content-Type: application/hal+json
  
        {
          "job": {
            "uuid": "ca234df1-3ef8-11ea-9a56-005056bb69a1",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/ca234df1-3ef8-11ea-9a56-005056bb69a1"
              }
            }
          }
        }
        ```
  
        ## Deleting a volume
  
        ## Example
        ### Deleting a volume
        The DELETE request is used to delete a volume.
        ```
        # The API:
        /api/storage/volumes
  
        # The call:
        curl -X DELETE  "https://<mgmt-ip>/api/storage/volumes/{uuid} " -H "accept: application/hal+json"
  
        # The response:
        HTTP/1.1 202 Accepted
        cache-control: no-cache,no-store,must-revalidate
        connection: Keep-Alive
        content-length: 189
        content-type: application/json
        date: Wed, 01 Aug 2018 09:40:36 GMT
        keep-alive: timeout=5, max=100
        server: libzapid-httpd
        {
          "job": {
            "uuid": "f1aa3eb8-956e-11e8-86bf-0050568e2249",
            "_links": {
              "self": {
                "href": "/api/cluster/jobs/f1aa3eb8-956e-11e8-86bf-0050568e2249"
              }
            }
          }
        }
        ```
  
    get:
      tags: [ storage ]
      description: |
        Retrieves volumes.
  
        ### Expensive properties
        There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
        * `is_svm_root`
        * `analytics.*`
        * `application.*`
        * `encryption.*`
        * `clone.parent_snapshot.name`
        * `clone.parent_snapshot.uuid`
        * `clone.parent_svm.name`
        * `clone.parent_svm.uuid`
        * `clone.parent_volume.name`
        * `clone.parent_volume.uuid`
        * `clone.split_complete_percent`
        * `clone.split_estimate`
        * `clone.split_initiated`
        * `efficiency.*`
        * `error_state.*`
        * `files.*`
        * `nas.export_policy.id`
        * `nas.gid`
        * `nas.path`
        * `nas.security_style`
        * `nas.uid`
        * `nas.unix_permissions`
        * `snaplock.*`
        * `restore_to.*`
        * `snapshot_policy.uuid`
        * `quota.*`
        * `qos.*`
        * `flexcache_endpoint_type`
        * `space.block_storage_inactive_user_data`
        * `space.capacity_tier_footprint`
        * `space.performance_tier_footprint`
        * `space.local_tier_footprint`
        * `space.footprint`
        * `space.over_provisioned`
        * `space.metadata`
        * `space.total_footprint`
        * `space.logical_space.*`
        * `space.snapshot.*`
        * `guarantee.*`
        * `autosize.*`
        * `movement.*`
        * `statistics.*`
  
        ### Related ONTAP commands
        * `volume show`
        * `volume clone show`
        * `volume efficiency show`
        * `volume encryption show`
        * `volume flexcache show`
        * `volume flexgroup show`
        * `volume move show`
        * `volume quota show`
        * `volume show-space`
        * `volume snaplock show`
  
      operationId: volume_collection_get
      parameters:
        - x-ntap-autogen-params: volume
        - $ref: '#/parameters/fields_param'
        - $ref: '#/parameters/max_records_param'
        - $ref: '#/parameters/return_records_get_param'
        - $ref: '#/parameters/return_timeout_get_param'
        - $ref: '#/parameters/order_by_param'
      responses:
        200:
          description: OK
          schema:
            $ref: "#/definitions/volume_response"
        default:
          description: Error
          schema:
            $ref: "#/definitions/error_response"
    post:
      tags: [ storage ]
      description: |
        Creates a volume on a specified SVM and storage aggregates.
  
        ### Required properties
        * `svm.uuid` or `svm.name` - Existing SVM in which to create the volume.
        * `name` - Name of the volume.
        * `aggregates.name` or `aggregates.uuid` - Existing aggregates in which to create the volume.
  
        ### Default property values
        * `state` -  _online_
        * `size` - _20MB_
        * `style` - _flexvol_
        * `type` - _rw_
        * `encryption.enabled` - _false_
        * `snapshot_policy.name` - _default_
        * `gaurantee.type` - _volume_
  
        ### Related ONTAP commands
        * `volume create`
        * `volume clone create`
  
      operationId: volume_create
      parameters:
        - name: info
          required: true
          in: body
          description: Info specification
          schema:
            $ref: "#/definitions/volume"
      responses:
        202:
          description: Accepted
          schema:
            $ref: "#/definitions/job_link_response"
        default:
          description: |
            - x-ntap-error-table-start: volume_errors.et,aggr_msgs.et,vserver_errors.et,analytics_errors.et
            - name: VOLUME_FIELD_NOT_ALLOWED
              message: The target field cannot be specified for this operation.
            - name: VSERVER_REST_POST_NO_SVM
              message: No SVM was specified. Either \"svm.name\" or \"svm.uuid\" must be supplied.
            - name: VOLUME_REST_CLONE_CREATE_INVALID_OPTION
              message: Specifying a value is not valid for a volume FlexClone creation.
            - name: VOLUME_REST_NO_CLONE_PARENT_VOL
              message: \"volume.clone.parent_volume.name\" or \"volume.clone.parent_volume.uuid\" must be provided.
            - name: VSERVER_UUID_NAME_MISMATCH
              message: The specified \"svm.uuid\" and \"svm.name\" do not refer to the same SVM.
            - name: VOLUME_UUID_NAME_MISMATCH
              message: The specified \"parent_volume.uuid\" and \"parent_volume.name\" do not refer to the same volume.
            - name: VOLUME_CLONE_SNAPSHOT_NAME_UUID_MISMATCH
              message: The specified Snapshot copy UUID is not correct for the specified Snapshot copy name.
            - name: VOLUME_REST_INVALID_CLONE_TYPE
              message: Invalid \"volume.type\" for clone volume.
            - name: VOLUME_REST_UNSUPPORTED_FLEXVOL_CONFIG
              message: When creating a flexible volume, exactly one aggregate must be specified via either \"aggregates.name\" or \"aggregates.uuid\".
            - name: VOLUME_REST_UNSUPPORTED_VOLUME_STYLE
              message: The target style is an unsupported volume style for volume creation.
            - name: VOLUME_REST_INVALID_VOLUME_STYLE
              message: The target style is an invalid volume style.
            - name: AGGREGATE_REST_POST_NO_AGGR
              message: One of \"aggregates.uuid\", \"aggregates.name\", or \"style\" must be provided.
            - name: AGGREGATE_UUID_NAME_MISMATCH
              message: The specified \"aggregates.name\" and \"aggregates.uuid\" refer to different aggregates.
            - name: VOLUME_REST_INVALID_PATH
              message: \"nas.path\" is invalid.
            - name: VOLUME_EXCEEDS_MAXIMUM_ALLOWED
              message: Maximum allowed snapshot.reserve_percent value during a volume creation is 90. Use PATCH to set it to a higher value after the volume has been created.
            - name: ANALYTICS_NO_CAPABILITY
              message: File system analytics requires an effective cluster version of 9.8 or later.
            - name: ANALYTICS_INVALID_STATE_FOR_CREATE_MODIFY
              message: The specified \"analytics.state\" is invalid.
            - name: ANALYTICS_LUNS_NOT_SUPPORTED
              message: File system analytics cannot be enabled on volumes that contain LUNs.
            - name: VOLUME_TIER_MIN_COOL_DAYS_MIXED_VERSION
              message: Flexvol tiering min cooling days requires an effective cluster version of ONTAP 9.4 or later.
            - name: VOLUME_TIER_MIN_COOL_DAYS_NOT_SUPPORTED_SVMDR
              message: Tiering min cooling days not supported for SVMDR.
            - name: VOLUME_TIER_MIN_COOL_DAYS_ON_NON_DATA_VOLUME
              message: Tiering min cooling days not supported for non data volumes.
            - name: VOLUME_TIER_MIN_COOL_DAYS_INVALID_TIERING_POLICY
              message: Tiering min cooling days not allowed for the provided tiering policy.
            - name: VOLUME_FG_TIER_MIN_COOL_DAYS_MODIFY_MIXED_VERSION
              message: FlexGroup tiering min cooling days requires an effective cluster version of ONTAP 9.5 or later.
            - name: VOLUME_CLOUD_RETRIEVE_POLICY_MIXED_VERSION
              message: cloud retrieval policy requires an effective cluster version of 9.8 or later.
            - name: VOLUME_CLOUD_RETRIEVE_POLICY_NOT_SUPPORTED
              message: Invalid volume cloud retrieval policy for the provided tiering policy.
            - name: VOLUME_CLOUD_RETRIEVE_POLICY_ON_NON_DATA_VOLUME
              message: cloud retrieval policy not supported for non data volume.
            - name: VOLUME_DUPLICATE_VOLUME_NAME
              message: The volume name specified is a duplicate.
            - name: VOLUME_AUTOSIZE_MAX_INVALID_VAL
              message: The volume maximum autosize must be smaller than or equal to the maximum volume size.
            - name: VOLUME_AUTOSIZE_MAX_MIN_INVALID
              message: Volume minimum autosize must be smaller than the maximum autosize.
            - name: VOLUME_AUTOSIZE_GS_THRESHOLDS_INVALID
              message: Volume autosize grow threshold must be larger than autosize shrink threshold.
            - name: VOLUME_AUTOSIZE_MIN_INVALID_VAL
              message: Volume minimum autosize must be less than or equal to the current volume size.
            - x-ntap-error-table-end: END
          schema:
            $ref: "#/definitions/error_response"
  
  /storage/volumes/{uuid}:
    get:
      tags: [ storage ]
      description: |
        Retrieves a volume. The GET API can be used to retrieve the quota state for a FlexVol or a FlexGroup volume.
  
        ### Expensive properties
        There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
        * `is_svm_root`
        * `analytics.*`
        * `application.*`
        * `encryption.*`
        * `clone.parent_snapshot.name`
        * `clone.parent_snapshot.uuid`
        * `clone.parent_svm.name`
        * `clone.parent_svm.uuid`
        * `clone.parent_volume.name`
        * `clone.parent_volume.uuid`
        * `clone.split_complete_percent`
        * `clone.split_estimate`
        * `clone.split_initiated`
        * `efficiency.*`
        * `error_state.*`
        * `files.*`
        * `nas.export_policy.id`
        * `nas.gid`
        * `nas.path`
        * `nas.security_style`
        * `nas.uid`
        * `nas.unix_permissions`
        * `snaplock.*`
        * `restore_to.*`
        * `snapshot_policy.uuid`
        * `quota.*`
        * `qos.*`
        * `flexcache_endpoint_type`
        * `space.block_storage_inactive_user_data`
        * `space.capacity_tier_footprint`
        * `space.performance_tier_footprint`
        * `space.local_tier_footprint`
        * `space.footprint`
        * `space.over_provisioned`
        * `space.metadata`
        * `space.total_footprint`
        * `space.logical_space.*`
        * `space.snapshot.*`
        * `guarantee.*`
        * `autosize.*`
        * `movement.*`
        * `statistics.*`
  
        ### Related ONTAP commands
        * `volume show`
        * `volume clone show`
        * `volume efficiency show`
        * `volume encryption show`
        * `volume flexcache show`
        * `volume flexgroup show`
        * `volume move show`
        * `volume quota show`
        * `volume show-space`
        * `volume snaplock show`
  
      operationId: volume_get
      parameters:
        - name: uuid
          in: path
          type: string
          description: Unique identifier of the volume.
          required: true
        - $ref: "#/parameters/fields_param"
      responses:
        200:
          description: OK
          schema:
            $ref: "#/definitions/volume"
        default:
          description: Error
          schema:
            $ref: "#/definitions/error_response"
    patch:
      tags: [ storage ]
      description: |
        Updates the attributes of a volume. For movement, use the "validate_only" field on the request to validate but not perform the operation. The PATCH API can be used to enable or disable quotas for a FlexVol or a FlexGroup volume. An empty path in PATCH deactivates and unmounts the volume. Taking a volume offline removes its junction path.
        <br>A PATCH request for volume encryption performs conversion/rekey operations asynchronously. You can retrieve the conversion/rekey progress details by calling a GET request on the corresponding volume endpoint.
  
        ### Optional properties
        * `queue_for_encryption` - Queue volumes for encryption when `encryption.enabled=true`.  If this option is not provided or is false, conversion of volumes starts immediately. When there are volumes in the queue and less than four encryptions are running, volumes are encrypted in the order in which they are queued.
  
        ### Related ONTAP commands
        * `volume unmount`
        * `volume mount`
        * `volume online`
        * `volume offline`
        * `volume modify`
        * `volume clone modify`
        * `volume efficiency modify`
        * `volume quota on`
        * `volume quota off`
        * `volume snaplock modify`
        * `volume encryption conversion start`
        * `volume encryption rekey start`
  
      operationId: volume_modify
      parameters:
        - name: uuid
          in: path
          description: Unique identifier of the volume.
          type: string
          required: true
        - name: restore_to.snapshot.uuid
          in: query
          description: UUID of the Snapshot copy to restore volume to the point in time the Snapshot copy was taken.
          type: string
        - name: restore_to.snapshot.name
          in: query
          description: Name of the Snapshot copy to restore volume to the point in time the Snapshot copy was taken.
          type: string
        - name: sizing_method
          in: query
          description: |
              Represents the method to modify the size of a Flexgroup. The following methods are supported:
              * use_existing_resources - Increases or decreases the size of the FlexGroup by increasing or decreasing the size of the current FlexGroup resources
              * add_new_resources - Increases the size of the FlexGroup by adding new resources
          type: string
          enum:
            - use_existing_resources
            - add_new_resources
          default: use_existing_resources
        - $ref: "#/parameters/validate_only_param"
        - name: info
          in: body
          description: Info specification
          schema:
            $ref: "#/definitions/volume"
      responses:
        202:
          description: Accepted
          schema:
            $ref: "#/definitions/job_link_response"
        default:
          description: |
            - x-ntap-error-table-start: olv_errors.et,volume_errors.et,aggr_msgs.et,analytics_errors.et
            - name: OLV_REST_CANNOT_ADD_NEW_RESOURCE_TO_FLEXVOL
              message: Resizing by adding new resources is only supported for FlexGroups.
            - name: OLV_REST_CANNOT_MANUAL_EXPAND_AND_RESIZE
              message: When adding new resources to a FlexGroup by specifying \"aggregates.name\" or \"aggregates.uuid\", the FlexGroup cannot be resized using \"size\". These operations must be done separately.
            - name: OLV_REST_CANNOT_AUTO_EXPAND
              message: When adding new resources to a FlexGroup using \"sizing_method\", \"size\" must be specified.  Neither \"aggregates.name\" nor \"aggregates.uuid\" are allowed to be specified, as the aggregates are selected automatically by the system.
            - name: AGGREGATE_UUID_NAME_MISMATCH
              message: The specified \"aggregates.name\" and \"aggregates.uuid\" refer to different aggregates.
            - name: VOLUME_REST_AGGREGATE_STATE_MUTUALLY_EXCLUSIVE
              message: \"movement.destination_aggregate\" and \"movement.state\" are mutually exclusive, unless the state is \"cutover-wait\".
            - name: VOLUME_REST_AGGREGATE_NOT_EXIST
              message: The specified \"movement.destination_aggregate\" does not exist.
            - name: VOLUME_REST_VOLUME_SAME_AGGREGATE
              message: Volume is on the same aggregate.
            - name: VOLUME_REST_CLONE_SPLIT_INVALID_OPTION
              message: Specifying a value is not valid for initiating volume FlexClone split operation.
            - name: VOLUME_REST_SNAP_RESTORE_INVALID_OPTION
              message: Specifying a value is not valid for a Snapshot copy restore operation.
            - name: VOLUME_REST_INVALID_PATH
              message: specified \"nas.path\" is invalid.
            - name: ANALYTICS_CANT_ENABLE
              message: File system analytics cannot be enabled on the target volume because of the specified reason.
            - name: ANALYTICS_CANT_DISABLE
              message: File system analytics cannot be disabled on the target volume because of the specified reason.
            - name: ANALYTICS_NO_CAPABILITY
              message: File system analytics requires an effective cluster version of 9.8 or later.
            - name: ANALYTICS_INVALID_STATE_FOR_CREATE_MODIFY
              message: The specified \"analytics.state\" is invalid.
            - name: ANALYTICS_LUNS_NOT_SUPPORTED
              message: File system analytics cannot be enabled on volumes that contain LUNs.
            - name: VOLUME_CANNOT_MODIFY_TIER_MIN_COOL_DAYS_DURING_VOLMOVE
              message: Cannot modify tiering min cooling days when vol move is in progress.
            - name: VOLUME_TIER_MIN_COOL_DAYS_NOT_SUPPORTED_SVMDR
              message: Tiering min cooling days not supported for SVMDR.
            - name: VOLUME_TIER_MIN_COOL_DAYS_ON_NON_DATA_VOLUME
              message: Tiering min cooling days not supported for non data volumes.
            - name: VOLUME_TIER_MIN_COOL_DAYS_INVALID_TIERING_POLICY
              message: Tiering min cooling days not allowed for the provided tiering policy.
            - name: VOLUME_CLOUD_RETRIEVE_POLICY_NOT_SUPPORTED
              message: Invalid volume cloud retrieval policy for the provided tiering policy.
            - name: VOLUME_CLOUD_RETRIEVE_POLICY_ON_NON_DATA_VOLUME
              message: cloud retrieval policy not supported for non data volume.
            - name: VOLUME_CANNOT_MODIFY_CLOUD_RETRIEVE_POLICY_DURING_VOLMOVE
              message: Cannot modify cloud retrieval policy when vol move is in progress.
            - name: VOLUME_AUTOSIZE_MAX_INVALID_VAL
              message: The volume maximum autosize must be smaller than or equal to the maximum volume size.
            - name: VOLUME_AUTOSIZE_MAX_MIN_INVALID
              message: Volume minimum autosize must be smaller than the maximum autosize.
            - name: VOLUME_AUTOSIZE_GS_THRESHOLDS_INVALID
              message: Volume autosize grow threshold must be larger than autosize shrink threshold.
            - x-ntap-error-table-end: END
          schema:
            $ref: "#/definitions/error_response"
  
    delete:
      tags: [ storage ]
      description: |
        Deletes a volume. If the UUID belongs to a volume, all of its blocks are freed and returned to its containing aggregate. If a volume is online, it is offlined before deletion. If a volume is mounted, unmount the volume by specifying the nas.path as empty before deleting it using the DELETE operation.
  
        ### Related ONTAP commands
        * `volume delete`
        * `volume clone delete`
  
      operationId: volume_delete
      parameters:
        - name: uuid
          in: path
          description: Unique identifier of the volume.
          required: true
          type: string
      responses:
        202:
          description: Accepted
          schema:
            $ref: "#/definitions/job_link_response"
        default:
          description: Error
          schema:
            $ref: "#/definitions/error_response"
  
  /storage/volumes/{volume.uuid}/metrics:
    get:
      tags: [ storage ]
      description: Retrieves historical performance metrics for a volume.
      operationId: volume_metrics_collection_get
      parameters:
        - x-ntap-autogen-params: volume_metrics
        - $ref: '#/parameters/return_timeout_get_param'
        - $ref: '#/parameters/fields_param'
        - $ref: '#/parameters/max_records_param'
        - $ref: '#/parameters/order_by_param'
        - $ref: '#/parameters/return_records_get_param'
        - name: volume.uuid
          in: path
          type: string
          description: Unique identifier of the volume.
          required: true
        - name: interval
          in: query
          type: string
          description: |
            The time range for the data. Examples can be 1h, 1d, 1m, 1w, 1y.
            The period for each time range is as follows:
            * 1h: Metrics over the most recent hour sampled over 15 seconds.
            * 1d: Metrics over the most recent day sampled over 5 minutes.
            * 1w: Metrics over the most recent week sampled over 30 minutes.
            * 1m: Metrics over the most recent month sampled over 2 hours.
            * 1y: Metrics over the most recent year sampled over a day.
          enum:
            - 1h
            - 1d
            - 1w
            - 1m
            - 1y
          default: 1h
      responses:
        200:
          description: OK
          schema:
            $ref: "#/definitions/volume_metrics_response"
        default:
          description: Error
          schema:
            $ref: "#/definitions/error_response"

definitions:
  volume:
    type: object
    properties:
      uuid:
        type        : string
        readOnly    : true
        example     : 028baa66-41bd-11e9-81d5-00a0986138f7
        description : Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.  

      comment:
        type        : string
        minLength   : 0
        maxLength   : 1023
        description : A comment for the volume. Valid in POST or PATCH.  

      create_time:
        type        : string
        readOnly    : true
        format      : date-time
        example     : '2018-06-04T19:00:00Z'
        description : Creation time of the volume. This field is generated when the volume is created.  

      language:
        type              : string
        x-ntap-readCreate : true
        enum:
          - ar
          - ar.utf_8
          - c
          - c.utf_8
          - cs
          - cs.utf_8
          - da
          - da.utf_8
          - de
          - de.utf_8
          - en
          - en.utf_8
          - en_us
          - en_us.utf_8
          - es
          - es.utf_8
          - fi
          - fi.utf_8
          - fr
          - fr.utf_8
          - he
          - he.utf_8
          - hr
          - hr.utf_8
          - hu
          - hu.utf_8
          - it
          - it.utf_8
          - ja
          - ja.utf_8
          - ja_jp.932
          - ja_jp.932.utf_8
          - ja_jp.pck
          - ja_jp.pck.utf_8
          - ja_jp.pck_v2
          - ja_jp.pck_v2.utf_8
          - ja_v1
          - ja_v1.utf_8
          - ko
          - ko.utf_8
          - nl
          - nl.utf_8
          - no
          - no.utf_8
          - pl
          - pl.utf_8
          - pt
          - pt.utf_8
          - ro
          - ro.utf_8
          - ru
          - ru.utf_8
          - sk
          - sk.utf_8
          - sl
          - sl.utf_8
          - sv
          - sv.utf_8
          - tr
          - tr.utf_8
          - utf8mb4
          - zh
          - zh.gbk
          - zh.gbk.utf_8
          - zh.utf_8
          - zh_tw
          - zh_tw.big5
          - zh_tw.big5.utf_8
          - zh_tw.utf_8
        description: Language encoding setting for volume. If no language is specified, the volume inherits its SVM language encoding setting.  

      name:
        type        : string
        minLength   : 1
        maxLength   : 203
        example     : vol_cs_dept
        description : Volume name. The name of volume must start with an alphabetic character (a to z or A to Z) or an underscore (_). The name must be 197 or fewer characters in length for FlexGroups, and 203 or fewer characters in length for all other types of volumes. Volume names must be unique within an SVM. Required on POST.  

      size:
        type        : integer
        description : Physical size of the volume, in bytes. The minimum size for a FlexVol volume is 20MB and the minimum size for a FlexGroup volume is 200MB per constituent. The recommended size for a FlexGroup volume is a minimum of 100GB per constituent. For all volumes, the default size is equal to the minimum size.  

      state:
        type        : string
        enum:
          - error
          - mixed
          - offline
          - online
        description : Volume state. A volume can only be brought online if it is offline. Taking a volume offline removes its junction path. The 'mixed' state applies to FlexGroup volumes only and cannot be specified as a target state. An 'error' state implies that the volume is not in a state to serve data.  

      style:
        type        : string
        x-ntap-readCreate : true
        enum:
          - flexvol
          - flexgroup
        description : The style of the volume. If "style" is not specified, the volume type is determined based on the specified aggregates. Specifying a single aggregate, without "constituents_per_aggregate", creates a flexible volume. Specifying multiple aggregates, or a single aggregate with "constituents_per_aggregate", creates a FlexGroup. Specifying a volume "style" creates a volume of that type. For example, if the style is "flexvol" you must specify a single aggregate. If the style is "flexgroup", the system either uses the specified aggregates or automatically provisions aggregates if there are no specified aggregates.<br>flexvol &dash; flexible volumes and FlexClone volumes<br>flexgroup &dash; FlexGroups.  

      is_svm_root:
        type        : boolean
        readOnly    : true
        description : Specifies whether the volume is a root volume of the SVM it belongs to.  

      access_time_enabled:
        type: boolean
        x-ntap-readModify: true
        description: Indicates whether or not access time updates are enabled on the volume.  

      type:
        type              : string
        x-ntap-readCreate : true
        enum:
          - rw
          - dp
          - ls
        default           : rw
        description       : Type of the volume.<br>rw &dash; read-write volume.<br>dp &dash; data-protection volume.<br>ls &dash; load-sharing `dp` volume. Valid in GET.  
  

      _links:
        $ref: "#/definitions/self_link"  

      aggregates:
        type: array
        description : Aggregate hosting the volume. Required on POST.
        items:
          $ref: "#/definitions/aggregate_reference"  

      constituents_per_aggregate:
        type: integer
        x-ntap-writeOnly: true
        minimum: 1
        maximum: 1000
        default: 1
        description: Specifies the number of times to iterate over the aggregates listed with the "aggregates.name" or "aggregates.uuid" when creating or expanding a FlexGroup. If a volume is being created on a single aggregate, the system will create a flexible volume if the "constituents_per_aggregate" field is not specified, and a FlexGroup if it is specified.  If a volume is being created on multiple aggregates, the system will always create a FlexGroup.  

      use_mirrored_aggregates:
        type              : boolean
        x-ntap-createOnly : true
        description       : Specifies whether mirrored aggregates are selected when provisioning a FlexGroup without specifying "aggregates.name" or "aggregates.uuid". Only mirrored aggregates are used if this parameter is set to 'true' and only unmirrored aggregates are used if this parameter is set to 'false'. Aggregate level mirroring for a FlexGroup can be changed by moving all of the constituents to the required aggregates. The default value is 'true' for a MetroCluster configuration and is 'false' for a non-MetroCluster configuration.  

      flexcache_endpoint_type:
        type: string
        readOnly: true
        enum:
          - none
          - cache
          - origin
        description: FlexCache endpoint type. <br>none &dash; The volume is neither a FlexCache nor origin of any FlexCache. <br>cache &dash; The volume is a FlexCache volume. <br>origin &dash; The volume is origin of a FlexCache volume.  

      is_object_store:
        type: boolean
        readOnly: true
        description: Specifies whether the volume is provisioned for an object store server.  

      application:
        type: object
        properties:
          name:
            type        : string
            readOnly    : true
            description : Name of the application to which the volume belongs. Available only when the volume is part of an application.
          uuid:
            type        : string
            readOnly    : true
            example     : 1cd8a442-86d1-11e0-ae1d-123478563412
            description : UUID of the application to which the volume belongs. Available only when the volume is part of an application.  

      autosize:
        type: object
        properties:
          maximum:
            type        : integer
            description : Maximum size in bytes up to which a volume grows automatically. This size cannot be less than the current volume size, or less than or equal to the minimum size of volume.
          minimum:
            type        : integer
            description : Minimum size in bytes up to which the volume shrinks automatically. This size cannot be greater than or equal to the maximum size of volume.
          grow_threshold:
            type        : integer
            description : Used space threshold size, in percentage, for the automatic growth of the volume. When the amount of used space in the volume becomes greater than this threhold, the volume automatically grows unless it has reached the maximum size. The volume grows when 'space.used' is greater than this percent of 'space.size'. The 'grow_threshold' size cannot be less than or equal to the 'shrink_threshold' size..
          shrink_threshold:
            type        : integer
            description : Used space threshold size, in percentage, for the automatic shrinkage of the volume.  When the amount of used space in the volume drops below this threshold, the volume automatically shrinks unless it has reached the minimum size. The volume shrinks when the 'space.used' is less than the 'shrink_threshold' percent of 'space.size'. The 'shrink_threshold' size cannot be greater than or equal to the 'grow_threshold' size.
          mode:
            type: string
            enum:
              - grow
              - grow_shrink
              - off
            description : Autosize mode for the volume.<br>grow &dash; Volume automatically grows when the amount of used space is above the 'grow_threshold' value.<br>grow_shrink &dash; Volume grows or shrinks in response to the amount of space used.<br>off &dash; Autosizing of the volume is disabled.  

      clone:
        type: object
        properties:
          is_flexclone:
            type        : boolean
            description : Specifies if this volume is a normal FlexVol or FlexClone. This field needs to be set when creating a FlexClone. Valid in POST.
          split_complete_percent:
            type        : integer
            readOnly    : true
            description : Percentage of FlexClone blocks split from its parent volume.
          split_estimate:
            type        : integer
            readOnly    : true
            description : Space required by the containing-aggregate to split the FlexClone volume.
          split_initiated:
            type        : boolean
            description : This field is set when split is executed on any FlexClone, that is when the FlexClone volume is split from its parent FlexVol. This field needs to be set for splitting a FlexClone form FlexVol. Valid in PATCH.
          parent_snapshot :
            $ref: "#/definitions/snapshot_reference"
          parent_svm:
            $ref: "#/definitions/svm_reference"
          parent_volume:
            $ref: "#/definitions/volume_reference"  

      consistency_group:
        type: object
        description: Consistency group the volume is part of.
        properties:
          name:
            type: string
            description: Name of the consistency group.
            example: consistency_group_1  

      encryption:
        type: object
        properties:
          enabled:
            type              : boolean
            description       : Creates an encrypted or an unencrypted volume. For POST, when set to 'true', a new key is generated and used to encrypt the given volume. In that case, the underlying SVM must be configured with the key manager. When set to 'false', the volume created will be unencrypted. For PATCH, when set to 'true', it encrypts an unencrypted volume. Specifying the parameter as 'false' in a PATCH operation for an encrypted volume is only supported when moving the volume to another aggregate.
          key_id:
            type        : string
            readOnly    : true
            description : The key ID used for creating encrypted volume. A new key-id is generated for creating an encrypted volume. This key-id is associated with the generated key.
          rekey:
            type              : boolean
            x-ntap-readModify : true
            description : If set to 'true', re-encrypts the volume with a new key. Valid in PATCH.
          state:
            type        : string
            readOnly    : true
            enum:
              - encrypted
              - encrypting
              - partial
              - rekeying
              - unencrypted
            description : Volume encryption state.<br>encrypted &dash; The volume is completely encrypted.<br>encrypting &dash; Encryption operation is in progress.<br>partial &dash; Some constituents are encrypted and some are not. Applicable only for FlexGroup volume.<br>rekeying. Encryption of volume with a new key is in progress.<br>unencrypted &dash; The volume is a plain-text one.
          type:
            type        : string
            readOnly    : true
            enum:
              - none
              - volume
              - aggregate
            description : Volume encryption type.<br>none &dash; The volume is a plain-text one.<br>volume &dash; The volume is encrypted with NVE (NetApp Volume Encryption).<br>aggregate &dash; The volume is encrypted with NAE (NetApp Aggregate Encryption).
          status:
            type: object
            properties:
              code :
                type        : string
                readOnly    : true
                description : Encryption progress message code.
              message:
                type        : string
                readOnly    : true
                description : Encryption progress message.  

      error_state:
        type: object
        properties:
          has_bad_blocks:
            type        : boolean
            readOnly    : true
            description : Indicates whether the volume has any corrupt data blocks. If the damaged data block is accessed, an IO error, such as EIO for NFS or STATUS_FILE_CORRUPT for CIFS, is returned.
          is_inconsistent:
            type        : boolean
            readOnly    : true
            description : Indicates whether the file system has any inconsistencies.<br>true &dash; File system is inconsistent.<br>false &dash; File system in not inconsistent.  

      files:
        type: object
        properties:
          maximum:
            type        : integer
            description : The maximum number of files (inodes) for user-visible data allowed on the volume. This value can be increased or decreased. Increasing the maximum number of files does not immediately cause additional disk space to be used to track files. Instead, as more files are created on the volume, the system dynamically increases the number of disk blocks that are used to track files. The space assigned to track files is never freed, and this value cannot be decreased below the current number of files that can be tracked within the assigned space for the volume. Valid in PATCH.
          used:
            type        : integer
            readOnly    : true
            description : Number of files (inodes) used for user-visible data permitted on the volume. This field is valid only when the volume is online.  

      guarantee:
        type: object
        properties:
          type:
            type: string
            enum:
              - volume
              - none
            description: The type of space guarantee of this volume in the aggregate.
          honored:
            type: boolean
            readOnly: true
            description: Is the space guarantee of this volume honored in the aggregate?  

      snapmirror:
        description: Specifies attributes for SnapMirror protection.
        type: object
        properties:
          is_protected:
            type: boolean
            readOnly: true
            description: Specifies whether a volume is a SnapMirror source volume, using SnapMirror to protect its data.  

      movement:
        description: Volume movement. All attributes are modify, that is, not writable through POST. Set PATCH state to destination_aggregate to initiate a volume move operation. Volume movement on FlexGroup constituents are not supported.
        type: object
        properties:
          destination_aggregate:
            $ref: '#/definitions/aggregate_reference'
          state:
            description: State of volume move operation. PATCH the state to "aborted" to abort the move operation. PATCH the state to "cutover" to trigger cutover. PATCH the state to "paused" to pause the volume move operation in progress. PATCH the state to "replicating" to resume the paused volume move operation. PATCH the state to "cutover_wait" to go into cutover manually. When volume move operation is waiting to go into "cutover" state, this is indicated by the "cutover_pending" state. A change of state is only supported if volume movement is in progress.
            type: string
            enum:
              - aborted
              - cutover
              - cutover_wait
              - cutover_pending
              - failed
              - paused
              - queued
              - replicating
              - success
            example: replicating
          percent_complete:
            readOnly: true
            description: Completion percentage
            type: integer
          cutover_window:
            description: Time window in seconds for cutover. The allowed range is between 30 to 300 seconds.
            type: integer
            default: 30
            example: 30
          tiering_policy:
            description: Tiering policy for FabricPool
            type: string
            x-ntap-modifyOnly: true
            enum:
              - all
              - auto
              - backup
              - none
              - snapshot_only  

      tiering:
        type: object
        properties:
          policy:
            type: string
            description: Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the cloud store when they become cold. FabricPool combines flash (performance tier) with a cloud store into a single aggregate. Temperature of a volume block increases if it is accessed frequently and decreases when it is not. Valid in POST or PATCH.<br>all &dash; This policy allows tiering of both Snapshot copies and active file system user data to the cloud store as soon as possible by ignoring the temperature on the volume blocks.<br>auto &dash; This policy allows tiering of both snapshot and active file system user data to the cloud store<br>none &dash; Volume blocks will not be tiered to the cloud store.<br>snapshot_only &dash; This policy allows tiering of only the volume Snapshot copies not associated with the active file system. The default tiering policy is "snapshot-only" for a FlexVol and "none" for a FlexGroup. The default minimum cooling period for the "snapshot-only" tiering policy is 2 days and for the "auto" tiering policy is 31 days.
            enum:
              - all
              - auto
              - backup
              - none
              - snapshot_only
          supported:
            type: boolean
            x-ntap-createOnly : true
            default: false
            description:  This parameter specifies whether or not FabricPools are selected when provisioning a FlexGroup without specifying "aggregates.name" or "aggregates.uuid". Only FabricPool aggregates are used if this parameter is set to true and only non FabricPool aggregates are used if this parameter is set to false. Tiering support for a FlexGroup can be changed by moving all of the constituents to the required aggregates. Note that in order to tier data, not only does the volume need to support tiering by using FabricPools, the tiering "policy" must not be 'none'. A volume that uses FabricPools but has a tiering "policy" of 'none' supports tiering, but will not tier any data.
          min_cooling_days:
            type: integer
            description: This parameter specifies the minimum number of days that user data blocks of the volume must be cooled before they can be considered cold and tiered out to the cloud tier. Note that this parameter is only used for tiering purposes and does not affect the reporting of inactive data. The value specified should be greater than the frequency with which applications in the volume shift between different sets of data. This parameter cannot be set when volume tiering policy is either "none" or "all". The default value of this parameter depends on the volume's tiering policy. See the tiering policy section of this documentation for corresponding default values. If the tiering policy on the volume gets changed, then this parameter will be reset to the default value corresponding to the new tiering policy.
            minimum: 2
            maximum: 183
          object_tags:
            type: array
            minItems: 0
            maxItems: 4
            uniqueItems: true
            description: This parameter specifies tags of a volume for objects stored on a FabricPool-enabled aggregate. Each tag is a key,value pair and should be in the format "key=value".
            items:
              type: string
              maxLength: 257
              pattern: "[_a-zA-Z][_a-zA-Z0-9]{0,126}=[_a-zA-Z0-9]{1,127}"
              example: "a_m=m_a"
              description: Each tag should be in the format "key=value". All keys and values must contain only alphanumeric characters or underscores. The first character of a key must either be an alphabetic character or an underscore. All keys must be unique for a volume. All keys and values have a maximum limit of 127 characters. A maximum of 4 tags are allowed per volume. To remove all existing tiering object tags, specify an empty list as the parameter value.  

      cloud_retrieval_policy:
        type: string
        description: |
          This parameter specifies the cloud retrieval policy for the volume. This policy determines which tiered out blocks to retrieve from the capacity tier to the performance tier. The available cloud retrieval policies are
          "default" policy retrieves tiered data based on the underlying tiering policy. If the tiering policy is 'auto', tiered data is retrieved only for random client driven data reads. If the tiering policy is 'none' or 'snapshot_only', tiered data is retrieved for random and sequential client driven data reads. If the tiering policy is 'all', tiered data is not retrieved.
          "on_read" policy retrieves tiered data for all client driven data reads.
          "never" policy never retrieves tiered data.
          "promote" policy retrieves all eligible tiered data automatically during the next scheduled scan. It is only supported when the tiering policy is 'none' or 'snapshot_only'. If the tiering policy is 'snapshot_only', the only data brought back is the data in the AFS. Data that is only in a snapshot copy stays in the cloud and if tiering policy is 'none' then all data is retrieved.
        enum:
          - default
          - on_read
          - never
          - promote  

      nas:
        type: object
        properties:
          gid:
            type        : integer
            default     : 0
            description : The UNIX group ID of the volume. Valid in POST or PATCH.
          path:
            type        : string
            example     : /user/my_volume
            description : The fully-qualified path in the owning SVM's namespace at which the volume is mounted. The path is case insensitive and must be unique within a SVM's namespace. Path must begin with '/' and must not end with '/'. Only one volume can be mounted at any given junction path. An empty path in POST creates an unmounted volume. An empty path in PATCH deactivates and unmounts the volume. Taking a volume offline removes its junction path. This attribute is reported in GET only when the volume is mounted.
          security_style:
            type        : string
            enum:
              - mixed
              - ntfs
              - unified
              - unix
            default     : unix
            description : Security style associated with the volume. Valid in POST or PATCH.<br>mixed &dash; Mixed-style security<br>ntfs &dash; NTFS/WIndows-style security<br>unified &dash; Unified-style security, unified UNIX, NFS and CIFS permissions<br>unix &dash; Unix-style security.
          uid:
            type        : integer
            default     : 0
            description : The UNIX user ID of the volume. Valid in POST or PATCH.
          unix_permissions:
            type        : integer
            example     : 0755
            description : UNIX permissions to be viewed as an octal number. It consists of 4 digits derived by adding up bits 4 (read), 2 (write) and 1 (execute). First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. The second digit selects permission for the owner of the file; the third selects permissions for other users in the same group; the fourth for other users not in the group. Valid in POST or PATCH. For security style "mixed" or "unix", the default setting is 0755 in octal (493 in decimal) and for security style "ntfs", the default setting is 0000. In cases where only owner, group and other permissions are given (as in 755, representing the second, third and fourth dight), first digit is assumed to be zero.
          export_policy:
            $ref: "#/definitions/export_policy_reference"  

      qos:
        type: object
        description: QoS information
        properties:
          policy:
            $ref: "#/definitions/qos_policy_reference"  

      snaplock:
        type: object
        properties:
          append_mode_enabled:
            type        : boolean
            example     : false
            description : Specifies if the volume append mode is enabled or disabled. When it is enabled, all the files created with write permissions on the volume are, by default, WORM appendable files. The user can append the data to a WORM appendable file but cannot modify the existing contents of the file nor delete the file until it expires.
            default     : false
          autocommit_period:
            type        : string
            example     : "P30M"
            description : Specifies the autocommit period for SnapLock volume. All files which are not modified for a period greater than the autocommit period of the volume are committed to the WORM state. The autocommit period value represents a duration and must be specified in the ISO-8601 duration format. The autocommit period can be in years, months, days, hours, and minutes. A period specified for years, months, and days is represented in the ISO-8601 format as "P<num>Y", "P<num>M", "P<num>D" respectively, for example "P10Y" represents a duration of 10 years. A duration in hours and minutes is represented by "PT<num>H" and "PT<num>M" respectively. The period string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example "P1Y10M" is not supported. Apart from the duration specified in the ISO-8601 format, the autocommit field also accepts the string "none".
            default     : "none"
          compliance_clock_time:
            type        : string
            format      : date-time
            example     : '2018-06-04T19:00:00Z'
            readOnly    : true
            description : This is the volume compliance clock time which is used to manage the SnapLock objects in the volume.
          expiry_time:
            type        : string
            format      : date-time
            readOnly    : true
            example     : '2018-08-05T11:05:00Z'
            description : Expiry time of the volume.
          is_audit_log:
            type        : boolean
            readOnly    : true
            example     : true
            description : Indicates if this volume has been configured as SnapLock audit log volume for the SVM .
          litigation_count:
            type        : integer
            readOnly    : true
            example     : 10
            description : Litigation count indicates the number of active legal-holds on the volume.
          privileged_delete:
            type        : string
            enum        :
              - disabled
              - enabled
              - permanently_disabled
            example     : enabled
            description : Specifies the privileged-delete attribute of a SnapLock volume. On a SnapLock Enterprise (SLE) volume, a designated privileged user can selectively delete files irrespective of the retention time of the file. SLE volumes can have privileged delete as disabled, enabled or permanently_disabled and for SnapLock Compliance (SLC) volumes it is always permanently_disabled.
          retention:
            type: object
            properties:
              default:
                type        : string
                example     : "P30Y"
                description : Specifies the default retention period that is applied to files while committing them to the WORM state without an associated retention period. The retention value represents a duration and must be specified in the ISO-8601 duration format. The retention period can be in years, months, days, hours, and minutes. A duration specified for years, months, and days is represented in the ISO-8601 format as "P<num>Y", "P<num>M", "P<num>D" respectively, for example "P10Y" represents a duration of 10 years. A duration in hours and minutes is represented by "PT<num>H" and "PT<num>M" respectively. The retention string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example "P1Y10M" is not supported. Apart from the duration specified in the ISO-8601 format, the duration field also accepts the string "infinite" to set an infinite retention period and the string "unspecified" to set an unspecified retention period.
              minimum:
                type        : string
                example     : "P30Y"
                description : Specifies the minimum allowed retention period for files committed to the WORM state on the volume. The retention value represents a duration and must be specified in the ISO-8601 duration format. The retention period can be in years, months, days, hours, and minutes. A duration specified for years, month,s and days is represented in the ISO-8601 format as "P<num>Y", "P<num>M", "P<num>D" respectively, for example "P10Y" represents a duration of 10 years. A duration in hours and minutes is represented by "PT<num>H" and "PT<num>M" respectively. The retention string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example "P1Y10M" is not supported. Apart from the duration specified in the ISO-8601 format, the duration field also accepts the string "infinite" to set an infinite retention period.
                default     : "P0Y"
              maximum:
                type        : string
                example     : "P30Y"
                description : Specifies the maximum allowed retention period for files committed to the WORM state on the volume. The retention value represents a duration and must be specified in the ISO-8601 duration format. The retention period can be in years, months, days, hours, and minutes. A duration specified for years, months, and days is represented in the ISO-8601 format as "P<num>Y", "P<num>M", "P<num>D" respectively, for example "P10Y" represents a duration of 10 years. A duration in hours and minutes is represented by "PT<num>H" and "PT<num>M" respectively. The retention string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example "P1Y10M" is not supported. Apart from the duration specified in the ISO-8601 format, the duration field also accepts the string "infinite" to set an infinite retention period.
                default     : "P30Y"
          unspecified_retention_file_count:
            type        : integer
            format      : int64
            readOnly    : true
            example     : 10
            description : Indicates the number of files with an unspecified retention time in the volume.
          type:
            type        : string
            enum:
              - compliance
              - enterprise
              - non_snaplock
            default     : non_snaplock
            readOnly    : true
            example     : enterprise
            description : The SnapLock type of the volume. <br>compliance &dash; A SnapLock Compliance(SLC) volume provides the highest level of WORM protection and an administrator cannot destroy a SLC volume if it contains unexpired WORM files. <br> enterprise &dash; An administrator can delete a SnapLock Enterprise(SLE) volume.<br> non_snaplock &dash; Indicates the volume is non-snaplock.  

      snapshot_policy:
        $ref: "#/definitions/snapshot_policy_reference"  

      efficiency:
        type: object
        properties:
          compression:
            type: string
            enum:
              - inline
              - background
              - both
              - none
              - mixed
            description: The system can be enabled/disabled compression.<br>inline &dash; Data will be compressed first and written to the volume.<br>background &dash; Data will be written to the volume and compressed later.<br>both &dash; Inline compression compresses the data and write to the volume, background compression compresses only the blocks on which inline compression is not run.<br>none &dash; None<br>mixed &dash; Read only field for FlexGroups, where some of the constituent volumes are compression enabled and some are disabled.
          dedupe:
            type: string
            enum:
              - inline
              - background
              - both
              - none
              - mixed
            description: The system can be enabled/disabled dedupe.<br>inline &dash; Data will be deduped first and written to the volume.<br>background &dash; Data will be written to the volume and deduped later.<br>both &dash; Inline dedupe dedupes the data and write to the volume, background dedupe dedupes only the blocks on which inline dedupe is not run.<br>none &dash; None<br>mixed &dash; Read only field for FlexGroups, where some of the constituent volumes are dedupe enabled and some are disabled.
          cross_volume_dedupe:
            type: string
            enum:
              - inline
              - background
              - both
              - none
              - mixed
            description: The system can be enabled/disabled cross volume dedupe. it can be enabled only when dedupe is enabled.<br>inline &dash; Data will be cross volume deduped first and written to the volume.<br>background &dash; Data will be written to the volume and cross volume deduped later.<br>both &dash; Inline cross volume dedupe dedupes the data and write to the volume, background cross volume dedupe dedupes only the blocks on which inline dedupe is not run.<br>none &dash; None<br>mixed &dash; Read only field for FlexGroups, where some of the constituent volumes are cross volume dedupe enabled and some are disabled.
          compaction:
            type: string
            enum:
              - inline
              - none
              - mixed
            description: The system can be enabled/disabled compaction.<br>inline &dash; Data will be compacted first and written to the volume.<br>none &dash; None<br>mixed &dash; Read only field for FlexGroups, where some of the constituent volumes are compaction enabled and some are disabled.
          policy:
            type: object
            properties:
              name:
                type: string
                description: Specifies the name of the efficiency policy.
          schedule:
            type: string
            readonly: true
            description: Schedule associated with volume.
  #space wart start
      space:
        type: object
        properties:
          available:
            type: integer
            readOnly: true
            description: The available space, in bytes.
          block_storage_inactive_user_data:
            type: integer
            readOnly: true
            description: The size that is physically used in the block storage of the volume and has a cold temperature. In bytes. This parameter is only supported if the volume is in an aggregate that is either attached to a cloud store or could be attached to a cloud store.
          capacity_tier_footprint:
            type: integer
            format: int64
            readOnly: true
            description: Space used by capacity tier for this volume in the FabricPool aggregate, in bytes.
          performance_tier_footprint:
            type: integer
            format: int64
            readOnly: true
            description: Space used by the performance tier for this volume in the FabricPool aggregate, in bytes.
          local_tier_footprint:
            type: integer
            format: int64
            readOnly: true
            description: Space used by the local tier for this volume in the aggregate, in bytes.
          footprint:
            type: integer
            format: int64
            readOnly: true
            description: Data used for this volume in the aggregate, in bytes.
          total_footprint:
            type: integer
            format: int64
            readOnly: true
            description: Data and metadata used for this volume in the aggregate, in bytes.
          logical_space:
            type: object
            properties:
              reporting:
                type: boolean
                default: false
                description: Specifies whether space reporting on the volume is done along with storage efficiency.
              enforcement:
                type: boolean
                default: false
                description: Specifies whether space accounting for operations on the volume is done along with storage efficiency.
              used_by_afs:
                type: integer
                readOnly: true
                description: The virtual space used by AFS alone (includes volume reserves) and along with storage efficiency, in bytes.
              available:
                type: integer
                readOnly: true
                description: The amount of space available in this volume with storage efficiency space considered used, in bytes.
          metadata:
            type: integer
            readOnly: true
            description: Space used by the volume metadata in the aggregate, in bytes.
          over_provisioned:
            type: integer
            readOnly: true
            description: The amount of space not available for this volume in the aggregate, in bytes.
          size:
            type: integer
            description: Total provisioned size. The default size is equal to the minimum size of 20MB, in bytes.
          snapshot:
            type: object
            properties:
              used:
                type: integer
                readOnly: true
                description: The total space used by Snapshot copies in the volume, in bytes.
              reserve_percent:
                type: integer
                default: 5
                description: The space that has been set aside as a reserve for Snapshot copy usage, in percent.
              autodelete_enabled:
                type: boolean
                default: false
                x-ntap-modifyOnly: true
                description: Specifies whether Snapshot copy autodelete is currently enabled on this volume.
          used:
            type: integer
            readOnly: true
            description: The virtual space used (includes volume reserves) before storage efficiency, in bytes.
  #Space wart end  

      metric:
        $ref: "#/definitions/volume_metrics"  

      statistics:
        $ref: "#/definitions/volume_statistics_reference"  

      svm:
        description : SVM containing the volume. Required on POST.
        $ref: "#/definitions/svm_reference"  

      analytics:
        type: object
        properties:
          supported:
            type: boolean
            readOnly    : true
            description : This field indicates whether or not file system analytics is supported on the volume.
                          If file system analytics is not supported, the reason will be specified in the "analytics.unsupported_reason" field.
          unsupported_reason:
            type: object
            properties:
              message:
                type: string
                description: If file system analytics is not supported on the volume, this field provides the error message explaining why.
                readOnly: true
                example: "File system analytics cannot be enabled on volumes that contain LUNs."
              code:
                type: string
                description: If file system analytics is not supported on the volume, this field provides the error code explaining why.
                readOnly: true
                example: "111411207"
          state:
            type: string
            enum:
              - unknown
              - initializing
              - off
              - on
            description: File system analytics state of the volume.
                         If this value is "on", ONTAP collects extra file system analytics information for all directories on the volume.  There will be a slight impact to I/O performance to
                         collect this information. If this value is "off", file system analytics information is not collected and not available to be viewed. If this value is "initializing",
                         that means file system analytics was recently turned on, and the initialization scan to gather information all all existing files and directories is currently running.
                         If this value is 'unknown' that means there was an internal error when determining the file system analytics state for the volume.
          scan_progress:
            type: integer
            readOnly: true
            description: Percentage of files in the volume that the file
                         system analytics initialization scan has processed.
                         Only returned when the state is `initializing`.
            example: 17  

  volume_reference:
    type: object
    properties:
      _links:
         $ref: "#/definitions/self_link"
      name:
        type        : string
        example     : volume1
        description : The name of the volume.
      uuid:
        type        : string
        example     : 028baa66-41bd-11e9-81d5-00a0986138f7
        description : Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.  

  volume_response:
    type: object
    properties:
      _links:
        $ref: "#/definitions/collection_links"
      num_records:
        type        : integer
        description : Number of records
      records:
        type: array
        items:
          $ref: "#/definitions/volume"

  volume_metrics:
    type: object
    x-ntap-readOnly: true
    description: Performance numbers, such as IOPS, latency and throughput.
    properties:
      timestamp:
        type: string
        format: date-time
        readOnly: true
        description: The timestamp of the performance data.
        example: '2017-01-25T11:20:13Z'
      status:
        type: string
        readOnly: true
        description: Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
        enum:
          - ok
          - error
          - partial_no_data
          - partial_no_uuid
          - partial_no_response
          - partial_other_error
          - negative_delta
          - backfilled_data
          - inconsistent_delta_time
          - inconsistent_old_data
        example: ok
      duration:
        type: string
        readOnly: true
        description: |
          The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
        enum:
          - PT15S
          - PT4M
          - PT30M
          - PT2H
          - P1D
          - PT5M
        example: PT15S
      iops:
        description: The rate of I/O operations observed at the storage object.
        readOnly: true
        $ref: "#/definitions/performance_metric_io_type_reference"
      throughput:
        description: The rate of throughput bytes per second observed at the storage object.
        readOnly: true
        $ref: "#/definitions/performance_metric_io_type_reference"
      latency:
        description: The round trip latency in microseconds observed at the storage object.
        readOnly: true
        $ref: "#/definitions/performance_metric_io_type_reference"
      cloud:
        type: object
        readOnly: true
        description: Performance numbers (IOPS and latency) for cloud store. These numbers are relevant only for volumes hosted on FabricPools.
        properties:
          timestamp:
            type: string
            format: date-time
            readOnly: true
            description: The timestamp of the performance data.
            example: '2017-01-25T11:20:13Z'
          status:
            type: string
            readOnly: true
            description: Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
            enum:
              - ok
              - error
              - partial_no_data
              - partial_no_uuid
              - partial_no_response
              - partial_other_error
              - negative_delta
              - backfilled_data
              - inconsistent_delta_time
              - inconsistent_old_data
            example: ok
          duration:
            type: string
            readOnly: true
            description: |
              The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
            enum:
              - PT15S
              - PT4M
              - PT30M
              - PT2H
              - P1D
              - PT5M
            example: PT15S
          iops:
            description: The rate of I/O operations observed at the storage object.
            readOnly: true
            $ref: "#/definitions/performance_metric_io_type_reference"
          latency:
            description: The round trip latency in microseconds observed at the storage object.
            readOnly: true
            $ref: "#/definitions/performance_metric_io_type_reference"
      flexcache:
        type: object
        readOnly: true
        description: Performance number for FlexCache used to measure cache effectiveness.
        properties:
          timestamp:
            type: string
            format: date-time
            readOnly: true
            description: The timestamp of the performance data.
            example: '2017-01-25T11:20:13Z'
          status:
            type: string
            readOnly: true
            description: Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
            enum:
              - ok
              - error
              - partial_no_data
              - partial_no_uuid
              - partial_no_response
              - partial_other_error
              - negative_delta
              - backfilled_data
              - inconsistent_delta_time
              - inconsistent_old_data
            example: ok
          duration:
            type: string
            readOnly: true
            description: |
              The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
            enum:
              - PT15S
              - PT5M
              - PT30M
              - PT2H
              - PT1D
            example: PT1D
          cache_miss_percent:
            type: integer
            description: Cache miss percentage.
            example: 20
      _links:
        $ref: "#/definitions/self_link"  

  volume_statistics_reference:
    type: object
    x-ntap-readOnly: true
    description: These are raw performance numbers, such as IOPS latency and throughput. These numbers are aggregated across all nodes in the cluster and increase with the uptime of the cluster.
    properties:
      timestamp:
        type: string
        format: date-time
        readOnly: true
        description: The timestamp of the performance data.
        example: '2017-01-25T11:20:13Z'
      status:
        type: string
        readOnly: true
        description: Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
        enum:
          - ok
          - error
          - partial_no_data
          - partial_no_uuid
          - partial_no_response
          - partial_other_error
          - negative_delta
          - backfilled_data
          - inconsistent_delta_time
          - inconsistent_old_data
        example: ok
      iops_raw:
        description: The number of I/O operations observed at the storage object. This can be used along with delta time to calculate the rate of I/O operations per unit of time.
        readOnly: true
        $ref: "#/definitions/performance_metric_io_type_reference"
      throughput_raw:
        description: Throughput bytes observed at the storage object. This can be used along with delta time to calculate the rate of throughput bytes per unit of time.
        readOnly: true
        $ref: "#/definitions/performance_metric_io_type_reference"
      latency_raw:
        description: The raw latency in microseconds observed at the storage object. This can be divided by the raw IOPS value to calculate the average latency per I/O operation.
        readOnly: true
        $ref: "#/definitions/performance_metric_io_type_reference"
      cloud:
        type: object
        readOnly: true
        description: These are raw performance numbers (IOPS and latency) for the cloud store. These numbers are aggregated across all nodes in the cluster and increase with the uptime of the cluster. These numbers are relevant only for volumes hosted on FabricPools.
        properties:
          timestamp:
            type: string
            format: date-time
            readOnly: true
            description: The timestamp of the performance data.
            example: '2017-01-25T11:20:13Z'
          status:
            type: string
            readOnly: true
            description: Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
            enum:
              - ok
              - error
              - partial_no_data
              - partial_no_uuid
              - partial_no_response
              - partial_other_error
              - negative_delta
              - backfilled_data
              - inconsistent_delta_time
              - inconsistent_old_data
            example: ok
          iops_raw:
            description: The number of I/O operations observed at the storage object. This can be used along with delta time to calculate the rate of I/O operations per unit of time.
            readOnly: true
            $ref: "#/definitions/performance_metric_io_type_reference"
          latency_raw:
            description: The raw latency in microseconds observed at the storage object. This can be divided by the raw IOPS value to calculate the average latency per I/O operation.
            readOnly: true
            $ref: "#/definitions/performance_metric_io_type_reference"
      flexcache_raw:
        type: object
        description: Performance numbers for FlexCache used to measure cache effectiveness.
        readOnly: true
        properties:
          timestamp:
            type: string
            format: date-time
            readOnly: true
            description: The timestamp of the performance data.
            example: '2017-01-25T11:20:13Z'
          status:
            type: string
            readOnly: true
            description: Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
            enum:
              - ok
              - error
              - partial_no_data
              - partial_no_uuid
              - partial_no_response
              - partial_other_error
              - negative_delta
              - backfilled_data
              - inconsistent_delta_time
              - inconsistent_old_data
            example: ok
          cache_miss_blocks:
            type: integer
            description: Blocks retrieved from origin in case of a cache miss. This can be divided by the raw client_requested_blocks and multiplied by 100 to calculate the cache miss percentage.
            example: 10
          client_requested_blocks:
            type: integer
            description: Total blocks requested by the client.
            example: 500

  error_arguments:
    type: object
    x-ntap-readOnly: true
    properties:
      message:
        type: string
        description: Message argument
        readOnly: true
      code:
        type: string
        description: Argument code
        readOnly: true
  
  error:
    type: object
    x-ntap-readOnly: true
    properties:
      message:
        type: string
        description: Error message
        readOnly: true
        example: "entry doesn't exist"
      code:
        type: string
        description: Error code
        readOnly: true
        example: "4"
      target:
        type: string
        description: The target parameter that caused the error.
        readOnly: true
        example: "uuid"
      arguments:
        type: array
        description: Message arguments
        readOnly: true
        items:
          $ref: "#/definitions/error_arguments"
  
  error_response:
    type: object
    x-ntap-readOnly: true
    properties:
      error:
        $ref: "#/definitions/error"
  
  error_responses:
    type: object
    x-ntap-readOnly: true
    properties:
      errors:
        type: array
        items:
          $ref: "#/definitions/error"
  
  job_link_response:
    type: object
    x-ntap-readOnly: true
    properties:
      job:
        $ref: "#/definitions/job_link"
  
  href:
    type: object
    x-ntap-readOnly: true
    properties:
      href:
        type: string
        readOnly: true
        example: "/api/resourcelink"
  
  self_link:
    type: object
    x-ntap-readOnly: true
    properties:
      self:
        $ref: "#/definitions/href"
  
  related_link:
    type: object
    x-ntap-readOnly: true
    properties:
      related:
        $ref: "#/definitions/href"
  
  collection_links:
    type: object
    x-ntap-readOnly: true
    properties:
      self:
        $ref: "#/definitions/href"
      next:
        $ref: "#/definitions/href"

  performance_metric_io_type_reference:
    type: object
    description: Indicates the type of I/O operation that can be associated with the type of performance metric. I/O operations can be "total", "read", "write", and "other". An I/O operation of type "total" is an aggregation of all operation types for any type of performance metric.
    properties:
      total:
        type: integer
        description: Performance metric aggregated over all types of I/O operations.
        example: 1000
      read:
        type: integer
        description: Performance metric for read I/O operations.
        example: 200
      write:
        type: integer
        description: Peformance metric for write I/O operations.
        example: 100
      other:
        type: integer
        description: Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.

  snapshot_policy_reference:
    description: This is a reference to the Snapshot copy policy.
    type: object
    properties:
      uuid:
        type: string
        example: 1cd8a442-86d1-11e0-ae1c-123478563412
      name:
        type: string
        example: default
      _links:
        $ref: "#/definitions/self_link"

  qos_policy_reference:
    type: object
    description: When "min_throughput_iops", "min_throughput_mbps", "max_throughput_iops" or "max_throughput_mbps" attributes are specified, the storage object is assigned to an auto-generated QoS policy group. If the attributes are later modified, the auto-generated QoS policy-group attributes are modified. Attributes can be removed by specifying "0" and policy group by specifying "none". Upon deletion of the storage object or if the attributes are removed, then the QoS policy-group is also removed.
    properties:
      uuid:
        type: string
        example: 1cd8a442-86d1-11e0-ae1c-123478563412
        description: The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
      name:
        type: string
        example: performance
        description: The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
      min_throughput_iops:
        type: integer
        default: 0
        example: 2000
        description: Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
      min_throughput_mbps:
        type: integer
        default: 0
        example: 500
        description: Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
      max_throughput_iops:
        type: integer
        example: 10000
        description: Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
      max_throughput_mbps:
        type: integer
        default: 0
        example: 500
        description: Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
      _links:
        $ref: "#/definitions/self_link"

  export_policy_reference:
    description: Export Policy
    type: object
    properties:
      id:
        type: integer
        example: 100
      name:
        type: string
        example: default
      _links:
        $ref: "#/definitions/self_link"

  svm_reference:
    type: object
    description: SVM, applies only to SVM-scoped objects.
    properties:
      uuid:
        description: |
          The unique identifier of the SVM.
        type: string
        example: 02c9e252-41be-11e9-81d5-00a0986138f7
      name:
        description: |
          The name of the SVM.
        type: string
        example: svm1
      _links:
        $ref: '#/definitions/self_link'

  snapshot_reference:
    type: object
    properties:
      uuid:
        type: string
        example: 1cd8a442-86d1-11e0-ae1c-123478563412
      name:
        type: string
        example: this_snapshot
      _links:
         $ref: "#/definitions/self_link"
  
  aggregate_reference:
    description: Aggregate
    type: object
    properties:
      uuid:
        type: string
        example: 1cd8a442-86d1-11e0-ae1c-123478563412
      name:
        type: string
        example: aggr1
      _links:
        $ref: "#/definitions/self_link"

  volume_metrics_response:
    type: object
    properties:
      records:
        type: array
        items:
          $ref: "#/definitions/performance_metric"
      num_records:
        type: integer
        description: Number of records
      _links:
        $ref: "#/definitions/collection_links"
  
  performance_metric:
    type: object
    x-ntap-readOnly: true
    description: Performance numbers, such as IOPS latency and throughput.
    properties:
      timestamp:
        type: string
        format: date-time
        readOnly: true
        description: The timestamp of the performance data.
        example: '2017-01-25T11:20:13Z'
      iops:
        description: The rate of I/O operations observed at the storage object.
        readOnly: true
        $ref: "#/definitions/performance_metric_io_type_reference"
      throughput:
        description: The rate of throughput bytes per second observed at the storage object.
        readOnly: true
        $ref: "#/definitions/performance_metric_io_type_reference"
      latency:
        description: The round trip latency in microseconds observed at the storage object.
        readOnly: true
        $ref: "#/definitions/performance_metric_io_type_reference"
      status:
        type: string
        readOnly: true
        description: Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
        enum:
          - ok
          - error
          - partial_no_data
          - partial_no_response
          - partial_other_error
          - negative_delta
          - not_found
          - backfilled_data
          - inconsistent_delta_time
          - inconsistent_old_data
          - partial_no_uuid
        example: ok
      duration:
        type: string
        readOnly: true
        description: |
          The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
        enum:
          - PT15S
          - PT4M
          - PT30M
          - PT2H
          - P1D
          - PT5M
        example: PT15S
      _links:
        $ref: "#/definitions/self_link"
  
  job_link:
    type: object
    properties:
      uuid:
        type: string
        format: uuid
        readOnly: true
        description: The UUID of the asynchronous job that is triggered by a POST, PATCH, or DELETE operation.
      _links:
        $ref: "#/definitions/self_link"

parameters:
  fields_param:
    name: fields
    in: query
    description: Specify the fields to return.
    type: array
    items:
      type: string
    collectionFormat: csv
  
  max_records_param:
    name: max_records
    in: query
    description: Limit the number of records returned.
    type: integer
  
  return_records_update_param:
    name: return_records
    in: query
    description: The default is false.  If set to true, the records are returned.
    type: boolean
    default: false
  
  return_records_get_param:
    name: return_records
    in: query
    description: The default is true for GET calls.  When set to false, only the number of records is returned.
    type: boolean
    default: true
  
  return_timeout_update_param:
    name: return_timeout
    in: query
    description: The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.
    type: integer
    minimum: 0
    maximum: 120
    default: 0
  
  return_timeout_get_param:
    name: return_timeout
    in: query
    description: The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
    type: integer
    minimum: 0
    maximum: 120
    default: 15
  
  order_by_param:
    name: order_by
    in: query
    description: Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
    type: array
    items:
      type: string
    collectionFormat: csv
  
  svm_path_param:
    name: svm.uuid
    in: path
    type: string
    description: UUID of the SVM to which this object belongs.
    required: true
  
  svm_query_param:
    name: svm.uuid
    in: query
    type: string
    description: Filter by UUID of the SVM to which this object belongs.
  
  validate_only_param:
    name: validate_only
    in: query
    type: boolean
    description: Validate the operation and its parameters, without actually performing the operation.
  
  host_connectivity_param:
    name: host_connectivity
    in: query
    type: boolean
    description: Test the connection to a specific host.
    default: false


